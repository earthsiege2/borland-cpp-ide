                               ERRMSGS.TXT
                               ===========

This file contains error and warning messages that can be generated by
Borland C++ 4.0. For additional messages, refer to the "Error
messages" appendix in the "Borland C++ User's Guide."

MESSAGE EXPLANATIONS
====================

Alias 'alias' defined in module 'module' is redefined
  Linker warning
	An ALIAS definition record specified a public symbol substitute
	that was already defined by another ALIAS. The second public
	symbol substitute will be used. ALIAS records are generated by
	the assembler when the ALIAS directive is used.

Assembler stack overflow
  Compiler error
	The assembler ran out of memory during compilation. Review the
	portion of code flagged by the error message to ensure that it
	uses memory correctly.

Automatic data segment exceeds 64K
  Linker error
	The sum of the DGROUP physical segment, local heap, and stack
	exceeds 64K. Fix this by specifying smaller values for the
	HEAPSIZE and STACKSIZE statements in the module definition file
	or by decreasing the size of the near data in DGROUP. The map
	file shows the sizes of the component segments in DGROUP. The /s
	TLINK command-line option is useful for determining how much each
	module contributes to DGROUP.

Base class 'class' is also a base class of 'class'
  Compiler warning
	A class inherits from the same base class both directly and
	indirectly. It is best to avoid this non-portable construct in
	your program code.

Can't inherit non-RTTI class from RTTI base 'class'
Can't inherit RTTI class from non-RTTI base 'class'
  Compiler error
	When virtual functions are present, the RTTI attribute of all
	base classes must match that of the derived class.

Cannot create pre-compiled header: code in header
  Compiler warning
	One of the headers contained a non-inline function body.

Cannot create pre-compiled header: initialized data in header
  Compiler warning
	One of the headers contained a global variable definition. In a C
	header, this message indicates that a global variable was
	initialized. In C++ header, this message indicates that a
	variable was not declared "extern."

Cannot create pre-compiled header: header incomplete
  Compiler warning
	The pre-compiled header ended in the middle of a declaration.
	This often happens when there is a missing "}" in a class
	definition that is located in a header file.

Cannot create pre-compiled header: write failed
  Compiler warning
	The compiler could not write to the pre-compiled header file.
	This is usually due to a full disk or a disk that is write
	protected.

Cannot use tiny or huge memory model with Windows
  Compiler error
	You must use the small, medium, compact, or large memory models
	when compiling Windows programs.

Compiler stack overflow
  Compiler error
	The compiler ran out of memory during compilation. Review the
	portion of code flagged by the error message to ensure that it
	uses memory correctly.

Couldn't build command line to RLINK.EXE
  Linker error
	The command line that was generated by the command line linker
	was longer than 128 bytes. RLINK.EXE was not run on the EXE.
	Shorten the file names passed in the .RES file list, put in fewer
	.RES files, or run RLINK separately.

Couldn't exec RLINK.EXE
  Linker error
	The command-line linker could not spawn RLINK.EXE to bind
	resources. Check to make sure that RLINK.EXE is on your path.

Debugging information overflow->try fewer modules with debug
information
  Linker error
	This message is generated when you have more than 64K types or
	symbols in a single OBJ file, or if you get more than 64K
	modules, source files (including .h files), scopes, logical debug
	segments, classes or optimized variables in the link. The
	solution is to turn off debug information in a few object
	modules.

DOSSEG directive ignored in "module"
  Linker warning
	This warning indicates that the DOSSEG directive is no longer
	supported by the linker.

"filename" ("linenum"): Duplicate external name in exports
  Linker warning
	Two export functions listed in the EXPORTS section of a module
	definition file defined the same external name. For example:

	EXPORTS
		AnyProc=MyProc1
		AnyProc=MyProc2

Duplicate file %s in list, not added!
  Librarian error
	When building a library module, you specified an object file more
	that once.

"filename" ("linenum"): Duplicate internal name in exports
  Linker warning
	Two export functions listed in the EXPORTS section of the module
	definition file defined the same internal name. For example:

	EXPORTS
		AnyProc1=MyProc
		AnyProc2=MyProc

"filename" ("linenum"): Duplicate internal name in imports
  Linker warning
	Two import functions listed in the IMPORTS section of the module
	definition file defined the same internal name. For example:

	IMPORTS
		AnyProc=MyMod1.MyProc1
		AnyProc=MyMod2.MyProc2

Exception handling not enabled
  Compiler error
	A 'try' block was found with the exception handling disabled.

Functions with exception specifications are not expanded inline
  Compiler warning
	Check your inline code for lines containing exception
	specifications.

Functions with taking class-by-value argument(s) are not expanded
inline
  Compiler warning
	When exception handling is enabled, functions that take class
	arguments by value cannot be expanded inline (Note that functions
	taking class parameters by reference are not subject to this
	restriction.)

Illegal local public in %m
  Linker warning
	The message occurs when the linker sees an LPUBDEF record with an
	offset of zero for a VIRDEF that resides in an overlay segment.
	This can happen if you are trying to use structured exception
	support in an application that uses overlays.

Import 'symbol' in module 'module' clashes with prior module
	An import symbol can appear only once in a library file. A module
	that is being added to the library contains an import that is
	already in a module of the library and it cannot be added again.

Import library 'library' encountered in obj list
  Linker error
	Import libraries (import.lib) are not permitted in the OBJ file
	list. They must always appear in the LIB file list.

Initialization is only partially bracketed
  Compiler warning
	When structures are initialized, nested pairs of braces can be
	used to mark the initialization of each member of the structure.
	Bracketing the the members ensures that your idea and the
	compiler's idea of the initializations are the same. The compiler
	issues this warning when the brackets are not equally matched.

Initializing 'enumeration' with 'type'
  Compiler warning
	You're trying to initialize an enum variable to a different type.
	For example,
	enum count {zero, one, two} x = 2;
	results in this warning because 2 is of type int, not type enum
	count. It's better programming practice to use an enum identifier
	instead of a literal integer when assigning to or initializing
	enum types.

	This error is reduced to a warning to let existing programs
	compile.

Invalid entry at "segment:offset". Application may not work in real
mode
  Linker warning
	This warning indicates that a necessary entry was missing from
	the entry table of your executable file. The application may not
	work in real mode unless you fix the code and data.

Invalid exe filename: 'filename'
  Linker error
	The exe filename had an incorrect extension, such as .OBJ, .MAP,
	.LIB, .DEF, or .RES.

Invalid extended dictionary in library 'library': extended
dictionaries ignored
  Linker warning
	The extended dictionary in the library is invalid. Run TLIB /E on
	the library.

Invalid map filename: 'filename'
  Linker error
	The map filename had an incorrect extension, such as .OBJ, .EXE,
	.DLL, .LIB, .DEF, or .RES.

Invalid size specified for segment alignment
  Linker error
	This error occurs if an invalid value is specified for the
	Segment Alignment setting. The value specified must be an
	integral multiple of 2 and less than 64K. Common values are 16
	and 512. This error only occurs when linking Windows
	applications.

Invalid size specified for segment packing
  Linker error
	An non-decimal number was provided on the command line for the
	segment packing size limit.

Invalid target->/T'target'
  Linker error
	The command-line linker found an invalid target. Valid targets
	are 'w' and 'd'.

'base' is not a public base class of 'class'
  Compiler error
	There is a mismatch in the operands of the .* or ->* operator;
	the class of the member pointer must match (or be a public base
	class of) the object operand.

'member' is not a valid valid template type member
  Compiler error
	A member of a template with some actual arguments that depend on
	the formal arguments of an enclosing template was found not to be
	a member of the specified template in a particular instance.

'function' is obsolete
  Compiler warning
	The compiler generates this warning message when it encounters a
	function that is obsolete. Functions marked by this error message
	will be removed from the next version of the product.

Limit of 254 segments for new executable file exceeded
  Linker error
	The new executable file format only allows for 254 segments.
	Examine the map file. Usually, one of two things cause the
	problem. If the application is large model, the code segment
	packing size could be so small that there are too many code
	segments. Increasing the code segment packing size with the /P
	option could help.

	The other possibility is that you have a lot of far data segments
	with only a few bytes of data in them. The map file will tell you
	if this is happening. In this case, reduce the number of far data
	segments. 

No automatic data segment
  Linker warning
	No group named DGROUP was found. Because Borland's initialization
	files define DGROUP, you will only see this error if you don't
	link with an initialization file and your program doesn't define
	DGROUP. Windows uses DGROUP to find the local data segment. The
	DGROUP is required for Windows applications (but not DLLs) unless
	DATA NONE is specified in the module definition file.

'new' and 'delete' not supported
  IDE debugger error
	The integrated debugger does not support the evaluation of 'new'
	and 'delete'.

New executable header overflowed 64K
  Linker error
	The size of all the components of the new executable header of a
	Windows application is greater than 64K. Usually this is caused
	by a very large RESIDENTNAME table. If your application exports
	many functions, try exporting more of them by ordinal, rather
	than by name.

No type information
  IDE debugger error
	The integrated debugger has no type information for this
	variable. Ensure that you've compiled the module with debug
	information.

Not a valid expression format type
  IDE debugger error
	You used an invalid format specifier following an expression in
	the integrated debugger. A valid format specifier is a repeat
	value (optional) followed by one of the following format
	specifiers: c, d, f[n], h, m, p, r, s, or x.

Out of memory at library 'library': extended dictionaries ignored
  Linker warning
	The linker ran out of memory allocating space to cache the
	extended dictionaries. The linker will ignore extended
	dictionaries and proceed with the link.

Overloaded function resolution not supported
  IDE debugger error
	The only time an overloaded function name can be used without
	actually calling the function is when a variable or parameter if
	a appropriate type is initialized or assigned. In this case, an
	overloaded function name has been used in some other context.

Overlays ignored in new executable image
  Linker warning
	This error occurs if you attempt to link a Windows program with
	the /o option on. Windows executables can't be overlaid,
	although, with discardable code segments, you should be able to
	achieve a similar effect.

Repeat count needs an lvalue
  IDE debugger error
	The expression before the comma in the Watch or Evaluate window
	must be a manipulable region of storage. For example, expressions
	like these are not valid:

	i++, 10d
	x = y, 10m

Resource binding failed
  Linker error
	While you were linking from the command line, RLINK.EXE reported
	an error while binding resources to your image.

Segment alignment factor too small
  Linker error
	This error occurs if the segment alignment factor is too small to
	represent the file addresses of the segments in the .EXE file.
	This error only occurs when linking for Windows. See the
	documentation for the /A option.

Segment 'segment' relocation data exceeds 64K
  Linker error
	The NE format only allows for 8192 relocations per segment.

Segment too large for segment table
  Linker error
	This error should never occur in practice. It means that a
	segment was bigger than 64K and its size cannot be represented in
	the executable file. This error can only occur when linking for
	Windows; the format of the executable file used for Windows does
	not support segments greater than 64K.

Side effects are not allowed
  IDE debugger error
	Side effects such as assignments, ++, or -- are not allowed in
	the debugger watch window. A common error is to use "x = y" (not
	allowed) instead of "x == y" to test the equality of "x" and "y."

Stack size is less than 1400h. It has been reset to 1400h.
  Linker warning
	Windows 3.0 requires the stack size of an application to be at
	least 1400h. If the automatic data segment (ADS) is near 64K, but
	your stack is less than 1400h, this can cause the ADS to overflow
	at load time, but not at link time. For a Windows application, to
	protect against this, the linker forces the stack size to be at
	least 1400h.

Stub program exceeds 64K
  Linker error
	This error occurs if a DOS stub program written for Windows
	application exceeds 64K. Stub programs are specified via the STUB
	module definition file statement. The linker only supports stub
	programs up to 64K.

Table limit exceeded->try linking with extended dictionaries
  Linker error
	This error occurs if you are linking many object modules, each
	with many segment definition records. Turning on extended
	dictionaries will cause the linker to process fewer modules,
	eliminating unnecessary caching of these records. Make sure that
	the libraries that are being linked ALL have extended
	dictionaries. If you are not sure, run TLIB /E on the libraries,
	and extended dictionaries will be constructed.

Type 'type' may not be defined here
  Compiler error
	Classes and enumerations may not be defined in certain places.
	For example, the return type specification of a function. The
	class or enum definition must be moved into a separate type
	declaration.

Unable to process debug information, disable tasm /zi option
  Linker error
	This happens when you compile .C or .CPP code with debug
	information, generating assembler output, and then run TASM on
	the result with the /zi option. Do not use the /zi option. The
	compiler already put out the appropriate debug information.

Undefined alias symbol 'symbol'
  Linker error
	An ALIAS definition record was encountered which specified a
	substitute public symbol for an external reference. The public
	symbol was never found. ALIAS records are generated by the
	assembler when the ALIAS directive is used.

Unknown Goodie
  Linker error
	An unsupported option was supplied to the command-line linker.
	See the documentation for currently supported Goodies (options).

User break, library aborted
  Librarian error
	You pressed <Ctrl><Break> to abort the build of the library.

Variable 'variable' has been optimized and is not available
  IDE debugger error
	You have tried to inspect, watch, or otherwise access a variable
	which the optimizer removed. This variable is never assigned a
	value and has no stack location. Recompile your program without
	optimizations if you need to inspect this variable.

Write failed, disk full?
  Linker error
	This occurs if the linker could not write all of the data it
	attempted to write. This is almost certainly caused by the disk
	being full.

*************************   End of File   *************************

