//----------------------------------------------------------------------------
// cScript
// (C) Copyright 1987, 1997 by Borland International, All Rights Reserved
//
// IDE.SPP
//    IDE top level event handling.
//
// $Revision:   1.59  $
//
//----------------------------------------------------------------------------

import IDE;
import editor;
import scriptEngine;
import bPopEditorKeyboard;

// Mark this module as being a library module.
library;

//
// File Menu provides handling for Open/SaveAS
//
on IDE:>FileOpen(declare acFileName, declare acToolName){
   if (!DoIDEFileOpen(acFileName, acToolName))
       return pass(acFileName, acToolName);
   return true;
}

on IDE:>FileClose(){
   if (!DoIDEFileClose())
       return pass();
   return true;
}

on IDE:>FileSave(){
   if (!DoIDEFileSave())
       return pass();
   return true;
}

on IDE:>FileSaveAs(declare filename){
   if (!DoIDEFileSaveAs(filename))
       return pass(filename);
   return true;
}

on IDE:>FileSaveAll(){
   if (!DoIDEFileSaveAll())
       return pass();
   return true;
}

on IDE:>FilePrint(declare filename){
   if (!DoIDEFilePrint())
       return pass(filename);
   return true;
}

//
// Edit Menu provides handling for Cut/Copy/Paste/Undo/Redo/SelectAll/BufferList
//
on IDE:>EditCut(){
   if (IsEditKeyboard()) {
      if (!DoIDEEditCut())
          return pass();
   } else {
      return pass();
   }
   return true;
}

on IDE:>EditCopy(){
   if (IsEditKeyboard()) {
      if (!DoIDEEditCopy())
          return pass();
   } else {
      return pass();
   }
   return true;
}

on IDE:>EditPaste(){
   if (IsEditKeyboard()) {
      if (!DoIDEEditPaste())
          return pass();
   } else {
      return pass();
   }
   return true;
}

on IDE:>EditUndo(){
   if (IsEditKeyboard()) {
      if (!DoIDEEditUndo())
          return pass();
   } else {
      return pass();
   }
   return true;
}

on IDE:>EditRedo(){
   if (IsEditKeyboard()) {
      if (!DoIDEEditRedo())
          return pass();
   } else {
      return pass();
   }
   return true;
}

on IDE:>EditClear(){
   if (IsEditKeyboard()) {
      if (!DoIDEEditClear())
          return pass();
   } else {
      return pass();
   }
   return true;
}

on IDE:>EditSelectAll(){
   if (IsEditKeyboard()) {
      if (!DoIDEEditSelectAll())
          return pass();
   } else {
      return pass();
   }
   return true;
}

on IDE:>EditBufferList(){
   if (!DoIDEEditBufferList())
       return pass();
   return true;
}

//
// Search Menu provides handling for Find/Replace/SearchAgain/PreviousMessage
//                                   & NextMessage
//

on IDE:>SearchFind(declare acText){
   if (IsEditKeyboard()) {
      if (!DoIDESearchFind())
          return pass(acText);
   } else {
      return pass(acText);
   }
}

on IDE:>SearchReplace(declare acSearch, declare acReplace){
   if (IsEditKeyboard()) {
      declare rv = false;
      declare bRestorePosition = false;
      if (!DoIDESearchReplace(bRestorePosition))
         if (bRestorePosition) {
            editor.TopView.Position.Save();
            editor.TopView.Block.Save();
            rv = pass(acSearch, acReplace);
            editor.TopView.Position.Restore();
            editor.TopView.Block.Restore();
            return rv;
         } else
            return pass(acSearch, acReplace);
   } else {
      return pass(acSearch, acReplace);
   }
}

on IDE:>SearchSearchAgain(){
   if (IsEditKeyboard()) {
      if (!DoIDESearchSearchAgain())
          return pass();
   } else {
      return pass();
   }
}

on IDE:>SearchPreviousMessage(){
   if (!DoIDESearchPreviousMessage())
       return pass();
   return true;
}

on IDE:>SearchNextMessage(){
   if (!DoIDESearchNextMessage())
       return pass();
   return true;
}

on IDE:>SearchBrowseSymbol(declare SymbolName){

   if (!initialized(SymbolName)) {
       SymbolName = editor.GetWord();
   } else if (SymbolName == "") {
       SymbolName = editor.GetWord();
   }

   return pass(SymbolName);
}

on IDE:>SearchLocateSymbol(declare SymbolName){

   if (!initialized(SymbolName)) {
       SymbolName = editor.GetWord();
   } else if (SymbolName == "") {
       SymbolName = editor.GetWord();
   }
   return pass(SymbolName);
}

//
// Support Methods.
//

IsEditKeyboard() {
   return (IDE.KeyboardManager.GetKeyboard() == IDE.KeyboardManager.GetKeyboard("Editor") ||
          IDE.KeyboardManager.GetKeyboard() == IDE.KeyboardManager.GetKeyboard("ClassExpert"));
}


on IDE:>ShowVersion(){
   .StatusBar = .FullName;
}

// called by the Editor's local menu
on IDE:>EditorOpenSource(){

   editor.OpenFileAtCursor();
}

on IDE:>DoFileOpen(declare FileName, declare ToolName, declare ProjectNode)
{
   if (ToolName != "Text Edit")
     return pass(FileName, ToolName, ProjectNode);
   if (editor.TopView == NULL)
     return pass(FileName, ToolName, ProjectNode);
   declare View = editor.TopView;
   declare NameString = new String(View.Buffer.FileName);
   if (NameString.SubString(0, 6).Text != "NONAME")
     return pass(FileName, ToolName, ProjectNode);
   if ((View.Buffer.IsModified) || (View.Buffer.Position.LastRow != 1))
     return pass(FileName, ToolName, ProjectNode);

   declare editBuffer = new EditBuffer(FileName);
   if (editBuffer != NULL) {
       declare oldBuffer = View.Attach(editBuffer);
       if (oldBuffer != NULL)
           oldBuffer.Destroy();
       return true;
   }

   return false;
}


on IDE:>KeyboardAssignmentsChanged(declare nameOfKbdFile){
 // Load the newly assigned keyboard.
 declare String sEmulation(IDE.KeyboardAssignmentFile);
 sEmulation = sEmulation.SubString(0,sEmulation.Index(".")-1).Text + "Emulation(false);";
 scriptEngine.Execute(sEmulation);

 // This End is paired with the Start from KeyboardAssignmentsChanging
 IDE.EndWaitCursor();

 return pass(nameOfKbdFile);
}

on IDE:>KeyboardAssignmentsChanging(declare nameOfKbdFile){

 // This Start is paired with the Stop from KeyboardAssignmentsChanged
 IDE.StartWaitCursor();

 if (bPopEditorKeyboard) {
     .KeyboardManager.Pop("Editor");
     bPopEditorKeyboard = false;
 }

 // Unload existing editor emulation assignments.
 declare String sEmulation(IDE.KeyboardAssignmentFile);
 sEmulation = sEmulation.SubString(0,sEmulation.Index(".")-1).Text + "Emulation(true);";
 scriptEngine.Execute(sEmulation);

 return pass(nameOfKbdFile);
}

on IDE:>KeywordHelp(){
   if (IsEditKeyboard()) {
      declare sniglet = editor.GetWord();
      return .HelpKeywordSearch(sniglet);
   } else {
      IDE.HelpContents();
   }
}

on IDE:>Compile(declare fileName){
   if(initialized(fileName)){
      .ProjectCompile();
      return;
   }
   declare target = new ProjectNode(fileName);
   return (target.Make());
}

on IDE:>ReportError(declare msgText){
   .MessageBeep();
   .StatusBar = msgText;
}

on IDE:>Assign(sequence, command, keyboard){
   return keyboard.Assign(sequence, command);
}

on IDE:>Unassign(sequence, keyboard){
        return keyboard.Unassign(sequence);
}

on IDE:>ToggleKeystrokeRecording(){

   declare curRec = .KeyboardManager.CurrentRecord;

   if (curRec != NULL) {
      if (curRec.IsRecording) {
         .KeyboardManager.StopRecord();
         .StatusBar = "Keystrokes recorded";
         return;
        }

       if (curRec.IsPaused) {
          .ReportError("Recording is currently paused");
          return;
       }
   }

   .KeyboardManager.StartRecord(.KeyboardManager.CurrentRecord);
   .StatusBar = "Defining keystroke recording";
}

declare kbdOverwriteMacro = NULL;

on IDE:>BriefKeystrokeRecording() {

   declare curRec = .KeyboardManager.CurrentRecord;

   if (curRec != NULL) {
      if (curRec.IsRecording) {
         .KeyboardManager.StopRecord();
         .StatusBar = "Keystrokes recorded";
         return;
        }

      if (kbdOverwriteMacro == NULL) {
          kbdOverwriteMacro = new Keyboard(FALSE);
	       kbdOverwriteMacro.Assign("<y>","IDE.BriefKeystrokeRecordingYes();",ASSIGN_IMPLICIT_SHIFT);
          kbdOverwriteMacro.DefaultAssignment = "IDE.BriefKeystrokeRecordingNo();";
      }

      .KeyboardManager.Push(kbdOverwriteMacro, "Editor", FALSE);
      bPopEditorKeyboard = true;
      .StatusBar = "Overwrite existing keystroke macro [yn]?";

   } else {
      .KeyboardManager.StartRecord(.KeyboardManager.CurrentRecord);
      .StatusBar = "Defining keystroke recording";
   }
}

on IDE:>BriefKeystrokeRecordingYes() {
   .KeyboardManager.Pop("Editor");
   bPopEditorKeyboard = false;
   .KeyboardManager.StartRecord(.KeyboardManager.CurrentRecord);
   .StatusBar = "Defining keystroke recording";
}

on IDE:>BriefKeystrokeRecordingNo() {
   .KeyboardManager.Pop("Editor");
   bPopEditorKeyboard = false;
   .StatusBar = "";
}

on IDE:>PlaybackKeystrokeRecording(){
        declare curRec = .KeyboardManager.CurrentRecord;

        if (curRec != NULL) {

        if(curRec.IsRecording){
         .ReportError("Can't playback while recording");
         return;
      }

      if(curRec.IsPaused){
         .ReportError("Can't playback while paused");
         return;
      }

      if(curRec.KeyCount == 0){
         .ReportError("Nothing to playback");
         return;
      }

      .KeyboardManager.Playback(curRec);
   }
}

// This event is triggered by an Alt-I preesed while viewing the HelpAbout Box
on IDE:>DisplayCredits(){
   Credits();
}
