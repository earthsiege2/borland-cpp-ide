//----------------------------------------------------------------------------
// cScript
// (C) Copyright 1995, 1997 by Borland International, All Rights Reserved
//
// ED_EPSLN.SPP
//    Script component of IDE's Editor Epsilon emulation.
//    Provides support services for editing environment.
//
// $Revision:   1.19  $
//
//----------------------------------------------------------------------------
// Epsilon Editor.
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Symbol Imports
//----------------------------------------------------------------------------

import IDE;
import editor;
import scriptEngine;
import bFileLoading;
import bPopEditorKeyboard;

//
// Mark this module as being a library module.
//
library;

//----------------------------------------------------------------------------
// Symbol Defines
//----------------------------------------------------------------------------

#define BOOKMARK_ID_SYSTEM_ONE   19
#define BOOKMARK_ID_SYSTEM_TWO   18
#define BOOKMARK_ID_SYSTEM_THREE 17
#define FUNCTION_CONTINUE 0
#define FUNCTION_END      1

//----------------------------------------------------------------------------
// Menu Vectors.
//----------------------------------------------------------------------------

DoIDEFileClose()      { return FUNCTION_CONTINUE; }
DoIDEFileOpen()       { return FUNCTION_CONTINUE; }
DoIDEFilePrint()      { return FUNCTION_CONTINUE; }
DoIDEFileSave()       { return FUNCTION_CONTINUE; }
DoIDEFileSaveAs()     { return FUNCTION_CONTINUE; }
DoIDEFileSaveAll()    { return FUNCTION_CONTINUE; }

DoIDEEditUndo()       { editor.Undo(); return FUNCTION_END; }
DoIDEEditRedo()       { editor.Redo(); return FUNCTION_END; }
DoIDEEditCut()        { editor.EmacsAppendNextMenuKillStart(); editor.EmacsKillRegion(); editor.EmacsAppendNextMenuKillEnd(); return FUNCTION_END; }
DoIDEEditCopy()       { editor.EmacsCopyRegion(); return FUNCTION_END;  }
DoIDEEditPaste()      { editor.EmacsYank(); return FUNCTION_END; }
DoIDEEditClear()      { editor.EmacsAppendNextMenuKillStart(); editor.EmacsKillRegion(); editor.EmacsAppendNextMenuKillEnd(); return FUNCTION_END; }
DoIDEEditSelectAll()  { editor.SelectAll(); return FUNCTION_END; }
DoIDEEditBufferList() { return FUNCTION_CONTINUE; }

DoIDESearchFind()     { editor.EmacsSetSearch(); return FUNCTION_CONTINUE; }
DoIDESearchReplace()  { editor.EmacsSetReplace(); return FUNCTION_CONTINUE; }
DoIDESearchSearchAgain() { return FUNCTION_CONTINUE; }

DoIDESearchPreviousMessage() { return FUNCTION_CONTINUE; }
DoIDESearchNextMessage()     { return FUNCTION_CONTINUE; }

//----------------------------------------------------------------------------
// Methods.
//----------------------------------------------------------------------------

//
// Used to autoload the Default emulation specific methods.
//
epsilonEmulation(bUnassign) {

   IDE.KeyboardManager.ScriptAbortKey = "<Ctrl-g>";
   IDE.KeyboardManager.ProcessKeyboardAssignments(scriptEngine.StartupDirectory+IDE.KeyboardAssignmentFile,bUnassign);

   if (bUnassign) {
      print "Epsilon emulation removed.";
      scriptEngine.Unload(typeid(module()));
   } else {
      print "Epsilon emulation enabled.";
   }
}

//----------------------------------------------------------------------------
// EPSILON Editor.
//----------------------------------------------------------------------------

#define EMACS_MARK BOOKMARK_ID_SYSTEM_THREE
#define EMACS_MAXIMUM_KILL_BUFFERS 10

class EmacsSubsystem {

   LoadMateFunctionality();

   // Buffer variables.
   declare nClipboardToken = 0;
   declare nKeysProcessedKill = -1;
   declare nKeysProcessedYankPop = -1;
   declare nKeysProcessedYank = -1;
   declare nKillBufferIndex = -1;
   declare nKillBufferCount = 0;
   declare array aKillBuffers[EMACS_MAXIMUM_KILL_BUFFERS+1];

   // Blocking variables.
   declare bTransparent = FALSE;

   // Direction Variable
   declare nPreferredColumn = 1;

   // Argument Variables
   declare nArgument = 0;
   declare nKeysEntered = 0;
   declare acCommand = NULL;

   // Keyboards
   declare kbdEditor = NULL;
   declare kbdEscape = NULL;
   declare kbdCarrot = NULL;
   declare kbdArgument = NULL;

   // Subsystem Methods
   StepKillBufferIndex() {

      if (nKillBufferCount != EMACS_MAXIMUM_KILL_BUFFERS)
         nKillBufferCount++;

      if (nKillBufferIndex == nKillBufferCount)
         nKillBufferIndex = 0;
      else
         nKillBufferIndex++;
   }

   BackKillBufferIndex() {
      if (nKillBufferIndex)
         nKillBufferIndex--;
      else
         nKillBufferIndex = nKillBufferCount;
   }

   SetKillBufferContents(declare acContents, declare ep, declare bReverse) {
      if (nKeysProcessedKill == IDE.KeyboardManager.KeysProcessed - 1 &&
         nKillBufferCount) {
         // Append to the current kill buffer
         declare nIndex = nKillBufferIndex;
         if (bReverse)
            aKillBuffers[nIndex] = new String(acContents + aKillBuffers[nIndex].Text);
         else
            aKillBuffers[nIndex] = new String(aKillBuffers[nIndex].Text + acContents);
            if (ep != NULL)
               ep.SetClipboard(aKillBuffers[nIndex].Text);
      } else {
         StepKillBufferIndex();
         aKillBuffers[nKillBufferIndex] = new String(acContents);
         if (ep != NULL)
            ep.SetClipboard(aKillBuffers[nKillBufferIndex].Text);
      }
      nKeysProcessedKill = IDE.KeyboardManager.KeysProcessed;
   }

   YankKillBufferContents(declare ep, declare popBuffer) {
      if (popBuffer)
         BackKillBufferIndex();
      if (nKillBufferIndex > -1) {
          if (initialized(aKillBuffers[nKillBufferIndex])) {
             declare aString = aKillBuffers[nKillBufferIndex];
             ep.SetClipboard(aString.Text);
             nClipboardToken = ep.GetClipboardToken();
             return aString.Text;
          }
      }
      // just in case they yank without ever having killed
      return "";
   }
};

//
// Instantiate the EmacsSubsystem class.
//
export declare EmacsSubsystem ess;

on editor:>Append() {
   declare eb = .BlockExists();

   if (eb != NULL) {
      declare ep = .TopView.Position;
      eb.Save();
      ep.Move(eb.StartingRow,eb.StartingColumn);
      ep.InsertScrap();
      ep.Move(eb.StartingRow,eb.StartingColumn);
      eb.Restore();
      eb.Cut();
   } else
      IDE.ReportError("No marked block");
}

//
// The next kill operations should append.
//
on editor:>EmacsAppendNextKill()
{
   ess.nKeysProcessedKill = IDE.KeyboardManager.KeysProcessed;
}

//
// The next kill operations should append if appending has been set and the menu is used.
//
on editor:>EmacsAppendNextMenuKillStart()
{
   if (ess.nKeysProcessedKill == IDE.KeyboardManager.KeysProcessed) 
       ess.nKeysProcessedKill = IDE.KeyboardManager.KeysProcessed-1;
}

//
// The next kill operations should no longer append if appending has been set and the menu is used.
//
on editor:>EmacsAppendNextMenuKillEnd()
{
   if (ess.nKeysProcessedKill == IDE.KeyboardManager.KeysProcessed-1) 
       ess.nKeysProcessedKill = IDE.KeyboardManager.KeysProcessed-2;
}

//
// The next operation should use this argument.
//
on editor:>EmacsArgument(declare nAmount)
{
   if (ess.kbdArgument == NULL) {
      ess.kbdArgument = new Keyboard(FALSE);
      declare kbd = ess.kbdArgument;
      kbd.Assign("<1>","editor.EmacsArgumentKeyPress(1,FALSE);");
      kbd.Assign("<2>","editor.EmacsArgumentKeyPress(2,FALSE);");
      kbd.Assign("<3>","editor.EmacsArgumentKeyPress(3,FALSE);");
      kbd.Assign("<4>","editor.EmacsArgumentKeyPress(4,FALSE);");
      kbd.Assign("<5>","editor.EmacsArgumentKeyPress(5,FALSE);");
      kbd.Assign("<6>","editor.EmacsArgumentKeyPress(6,FALSE);");
      kbd.Assign("<7>","editor.EmacsArgumentKeyPress(7,FALSE);");
      kbd.Assign("<8>","editor.EmacsArgumentKeyPress(8,FALSE);");
      kbd.Assign("<9>","editor.EmacsArgumentKeyPress(9,FALSE);");
      kbd.Assign("<Alt-1>","editor.EmacsArgumentKeyPress(1,TRUE);");
      kbd.Assign("<Alt-2>","editor.EmacsArgumentKeyPress(2,TRUE);");
      kbd.Assign("<Alt-3>","editor.EmacsArgumentKeyPress(3,TRUE);");
      kbd.Assign("<Alt-4>","editor.EmacsArgumentKeyPress(4,TRUE);");
      kbd.Assign("<Alt-5>","editor.EmacsArgumentKeyPress(5,TRUE);");
      kbd.Assign("<Alt-6>","editor.EmacsArgumentKeyPress(6,TRUE);");
      kbd.Assign("<Alt-7>","editor.EmacsArgumentKeyPress(7,TRUE);");
      kbd.Assign("<Alt-8>","editor.EmacsArgumentKeyPress(8,TRUE);");
      kbd.Assign("<Alt-9>","editor.EmacsArgumentKeyPress(9,TRUE);");
      kbd.Assign("<Ctrl-u>","editor.EmacsArgumentKeyPress(0,TRUE);");
      kbd.DefaultAssignment = "editor.EmacsArgumentDoAction();";
   }

   if (initialized(nAmount))
      ess.nArgument = nAmount;
   else
      ess.nArgument = 4;
      
   ess.nKeysEntered = 0;
   ess.acCommand = NULL;
   ess.kbdEditor = IDE.KeyboardManager.GetKeyboard("Editor");
   IDE.KeyboardManager.Push(ess.kbdArgument, "Editor", FALSE);
   bPopEditorKeyboard = true;
   IDE.StatusBar = "Argument: " + ess.nArgument;
}

on editor:>EmacsArgumentKeyPress(declare nAmount, declare bDirectValue) {
   if (bDirectValue) {
      if (nAmount == 0) {
         ess.nArgument = ess.nArgument * 4;
      } else {
         ess.nArgument = nAmount;
      }
   } else {
      declare String sValue(ess.nArgument);
      declare String sAmount(nAmount);
      declare String sTotal(sValue.Text + sAmount.Text);
      ess.nArgument = sTotal.Integer;
   }

   IDE.StatusBar = "Argument: " + ess.nArgument;
}


on editor:>EmacsArgumentDoAction() {

   declare km = IDE.KeyboardManager;

   if (ess.nKeysEntered < 2) {
       ess.nKeysEntered++;
       declare String sCommand(ess.kbdEditor.GetCommand(km.CodeToKey(km.LastKeyProcessed)));
       if (sCommand.Length)
          ess.acCommand = sCommand;
       else {
          if (km.LastKeyProcessed < 128) {
           declare k = new String();
           k.Character = km.LastKeyProcessed;
           ess.acCommand = k;
          }
       }
  }

   if (ess.acCommand != NULL) {
      declare nIndex = 0;
      if (ess.acCommand.Length == 1)
         ess.acCommand = new String("editor.TopView.Position.InsertText(\""+ess.acCommand.Text+"\");");
      for (nIndex = 0;nIndex < ess.nArgument; nIndex++) {
         scriptEngine.Execute(ess.acCommand.Text);
      }
      ess.nKeysEntered = 2;
   }

   if (ess.nKeysEntered > 1) {
      km.Pop("Editor");
      bPopEditorKeyboard = false;
      IDE.StatusBar = "";
   }
}

on editor:>EmacsBackwardCharacter(declare withDelete) {
   declare ep = .TopView.Position;

   if (ep.Column == 1 && ep.Row != 1) {
      .ModalMoveRelative(-1, 0);
      .ModalMoveEOL();
   } else {
      .ModalMoveRelative(0, -1);
   }

   if (withDelete)
      ep.Delete(1);

   ess.nPreferredColumn = ep.Column;
}

//
// Move the point backward to the previous tab stop.
//
on editor:>EmacsBackToTabStop() {
   declare nDistance = .TopView.Position.DistanceToTab(SEARCH_BACKWARD);
   .TopView.Position.MoveRelative(0,nDistance);
}

//
// Kill backwards one bracketed expression level.
//
on editor:>EmacsBackwardKillLevel() {
   // Search for ')', '}' or ']'

   declare ep = .TopView.Position;
   declare eb = .TopView.Block;

   ResetBlock(EXCLUSIVE_BLOCK);
   EndBlock(EXCLUSIVE_BLOCK);

   declare nResult = ep.Search("[\]})]",TRUE,TRUE,SEARCH_BACKWARD);

   if (nResult) {
      if (.MateQuiet(ep.Read(1), SEARCH_BACKWARD)) {
         eb.Begin();
         if (eb.Size) {
            ess.SetKillBufferContents(eb.Text,ep,true);
            RemoveBlock(eb);
         }
      }
   }

   ResetBlock();
}

//
// Kill backwards one word.
//
on editor:>EmacsBackwardKillWord() {

   declare ep = .TopView.Position;
   declare eb = .TopView.Block;

   ResetBlock(EXCLUSIVE_BLOCK);

   eb.End();
   .EmacsBackwardWord();
   eb.Begin();

   if (eb.Size) {
      ess.SetKillBufferContents(eb.Text,ep,true);
      RemoveBlock(eb);
   }
}

//
// Move backwards one bracketed expression level.
//
on editor:>EmacsBackwardLevel() {
   // Search for ')', '}' or ']'
   declare bBlock = FALSE;
   declare eb = .BlockExists();
   declare ep = .TopView.Position;

   if (eb != NULL)
      bBlock = TRUE;

   declare nResult = ep.Search("[\]})]",TRUE,TRUE,SEARCH_BACKWARD);

   if (nResult && .MateQuiet(ep.Read(1), SEARCH_BACKWARD) && bBlock)
      eb.Begin();
}

//
// Move backwards one paragraph.
//
on editor:>EmacsBackwardParagraph() {

   declare bBlock = FALSE;
   declare eb = .BlockExists();
   declare ep = .TopView.Position;

   if (eb != NULL) {
      bBlock = TRUE;
   }

   if (ep.Column == 1 && ep.IsWhiteSpace)
      ep.MoveRelative(-1,0);
   else
      ep.Move(0,1);

   while (ep.Row != 1) {
      if (ep.IsWhiteSpace) {
         break;
      }
      ep.MoveRelative(-1,0);
   }

   if (bBlock) {
      eb.Begin();
   }
}

//
// Move backwards one paragraph.
//
on editor:>EmacsBackwardSentence() {
}

//
// Move backwards one word.
//
on editor:>EmacsBackwardWord() {
   declare ep = .TopView.Position;
   declare eb = .BlockExists();

   if (eb != NULL) {
      ep.Save();
      eb.Save();
   }

   do {
       ep.MoveCursor(SKIP_LEFT | SKIP_WHITE | SKIP_STREAM);
       ep.MoveCursor(SKIP_LEFT | SKIP_NONWORD | SKIP_STREAM);
       ep.MoveCursor(SKIP_LEFT | SKIP_WORD);
   } while (!ep.IsWordCharacter && ep.Row != 1);

   if (eb != NULL) {
      declare row = ep.Row;
      declare column = ep.Column;
      ep.Restore();
      eb.Restore();
      eb.Extend(row, column);
   }
}

//
// Move to the beginning of the window.
//
on editor:>EmacsBeginningOfWindow() {
   .ModalMoveViewTop();
   .ModalMoveBOL();
}

//
// Move to the ending of the window.
//
on editor:>EmacsEndingOfWindow() {
   .ModalMoveViewBottom();
   .ModalMoveEOL();
}

//
// Summarize line information.
//
on editor:>EmacsCountLines() {
   declare ep = .TopView.Position;

   declare String s(ep.Read());
   declare ll =  ep.Column + s.Length - 3;

   IDE.StatusBar = "Lines = " + ep.LastRow +
   " Line Number = " + ep.Row + " Line Length = " + ll;
}

//
// Summarize line information.
//
on editor:>EmacsCapitalizeWord() {
   if (.BlockExists())
      ResetBlock(EXCLUSIVE_BLOCK);

   if (!.TopView.Position.IsWordCharacter) {
      .EmacsForwardWord();
      .EmacsBackwardWord();
   }

   BeginBlock(EXCLUSIVE_BLOCK);
   .EmacsForwardCharacter();
   declare eb = EndBlock();
   eb.UpperCase();
   if (.TopView.Position.IsWordCharacter) {
      BeginBlock(EXCLUSIVE_BLOCK);             // implied call to Reset
      .EmacsForwardWord();
      eb = EndBlock();
      eb.LowerCase();
   }
   ResetBlock(EXCLUSIVE_BLOCK);
}

//
// Copy the highlighted region to a kill buffer.
//
on editor:>EmacsCopyRegion() {

   ess.nKeysProcessedKill = 0;

   declare eb = .BlockExists();

   if (eb != NULL) {
      ess.SetKillBufferContents(eb.Text,.TopView.Position,false);
      CopyBlock(eb,false);
   } else {
      declare ev = .TopView;
      declare ep = ev.Position;
      eb = ev.Block;

      ep.Save();
      eb.Begin();
      ev.BookmarkGoto(EMACS_MARK);
      eb.End();

      if (eb.Size) {
         ess.SetKillBufferContents(eb.Text,ep,false);
         CopyBlock(eb,false);
      }
      ep.Restore();
      ResetBlock();
   }
}


//
// Using EMACS behaviour setup a keyboard to use the ctrl version of
// the next key.
//
on editor:>EmacsCtrlPrefix()
{
   if (ess.kbdCarrot == NULL) {
      ess.kbdCarrot = new Keyboard(FALSE);
      ess.kbdCarrot.DefaultAssignment = "editor.EmacsCtrlPrefixKeyPress();";
   }

   IDE.KeyboardManager.Push(ess.kbdCarrot, "Editor", FALSE);
   bPopEditorKeyboard = true;
   IDE.StatusBar = "<Ctrl>";
}

on editor:>EmacsCtrlPrefixKeyPress() {

   declare km = IDE.KeyboardManager;
   km.Pop("Editor");
   bPopEditorKeyboard = false;
   declare String sKey(km.CodeToKey(km.LastKeyProcessed));
   declare nIndex = sKey.Index(">");
   if (nIndex > 2)
      sKey = sKey.SubString(1,nIndex-2);
   sKey = "^" + sKey.Text;
   km.SendKeys(sKey,TRUE);
}


//
// Using EMACS behavior delete blank lines around the point.
//
on editor:>EmacsDeleteBlankLines() {

   declare ep = .TopView.Position;

   .TopView.BookmarkRecord(BOOKMARK_ID_SYSTEM_ONE);

   if (ep.IsWhiteSpace || ep.Character == 13) {

       declare eb = .TopView.Block;

       ep.MoveCursor(SKIP_LEFT | SKIP_WHITE | SKIP_STREAM);

       if (ep.Column != 1)
           ep.MoveRelative(1,0);

       declare nBeginingRow = ep.Row;

       ep.MoveBOL();

       ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE | SKIP_STREAM);

       if (!ep.IsWhiteSpace)
           ep.MoveRelative(-1,0);

                 declare nEndingRow = ep.Row;

       if (nEndingRow == nBeginingRow) {
           ep.Move(nBeginingRow,1);
           eb.Begin();
           ep.Move(nEndingRow+1,1);
           eb.End();
           eb.Delete();
       } else {
           ep.Move(nBeginingRow,1);
           eb.Begin();
           ep.Move(nEndingRow,1);
           eb.End();
           eb.Delete();
       }
   }

   .TopView.BookmarkGoto(BOOKMARK_ID_SYSTEM_ONE);
}

//
// Using EMACS behavior delete the current word.
//
on editor:>EmacsDeleteWord() {
   declare ep = .TopView.Position;
   declare eb = .TopView.Block;

   ep.Save();

   BeginBlock(EXCLUSIVE_BLOCK);
   .EmacsForwardWord();
   EndBlock();
   ess.SetKillBufferContents(eb.Text,ep,false);
   RemoveBlock(eb);

   ep.Restore();
}

on editor:>EmacsDeleteHorizontalSpace() {
   declare ep = .TopView.Position;
   declare eb = .TopView.Block;

   ResetBlock(EXCLUSIVE_BLOCK);
   ep.MoveCursor(SKIP_LEFT | SKIP_WHITE);
   BeginBlock(EXCLUSIVE_BLOCK);
   ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE);
   EndBlock();
   RemoveBlock(eb,TRUE);
}

on editor:>EmacsEnlargeWindow() {
   IDE.SetWindowState(SW_MAXIMIZE);
}

on editor:>EmacsEnlargeWindowHorizontal() {
}

on editor:>EmacsForwardCharacter() {
   declare ep = .TopView.Position;

   if (ep.Character == 13) {
      .ModalMoveRelative(1, 0);
      .ModalMoveBOL();
   }
   else {
      .ModalMoveRelative(0,1);
   }

 ess.nPreferredColumn = ep.Column;
}

on editor:>EmacsForwardLevel() {
   // must be on '(', '{' or '['
   declare bBlock = FALSE;
   declare eb = .BlockExists();
   declare ep = .TopView.Position;
   if (eb != NULL) {
      bBlock = TRUE;
   }

   declare nResult = ep.Search("[\]})]",TRUE,TRUE,SEARCH_FORWARD);

   if (nResult) {
      if (.MateQuiet(ep.Read(1), SEARCH_FORWARD)) {
         if (bBlock) {
            eb.Begin();
         }
      }
   }
}

on editor:>EmacsForwardSentance() {
}

on editor:>EmacsIndentRegion() {
   // IndentBlock
   declare eb = .BlockExists();
   if (eb != NULL) {
      eb.Indent(.Options.BlockIndent);
   }
}

on editor:>EmacsIndentUnder() {
   // SmartTab
   .TopView.Position.Align(1);
}

//
// Begins incremental searching of current buffer.
//
declare EmacsISearchKbd = NULL;
declare EmacsISearchString = "";
declare EmacsISearchDirection = SEARCH_FORWARD;

on editor:>EmacsIncrementalSearch(declare direction) {

   if (EmacsISearchKbd == NULL) {
       EmacsISearchKbd = new Keyboard(false);      // not transparent
       EmacsISearchKbd.Assign("<Minus>","editor.EmacsISearchMinus();");
       EmacsISearchKbd.Assign("<Space>","editor.EmacsISearchSpace();");
       EmacsISearchKbd.Assign("<Backspace>","editor.EmacsISearchBackspace();");
       EmacsISearchKbd.Assign("<Ctrl-g>","IDE.KeyboardManager.SendKeys(\"{VK_ESCAPE}\");");
       EmacsISearchKbd.Assign("<Ctrl-r>","editor.EmacsISearchBackward();");
       EmacsISearchKbd.Assign("<Ctrl-s>","editor.EmacsISearchForward();");
       EmacsISearchKbd.DefaultAssignment = "editor.EmacsISearchKey();";
   }

   if (initialized(direction))
      EmacsISearchDirection = direction;
   else {
       if (.SearchOptions.GoForward)
          EmacsISearchDirection = SEARCH_FORWARD;
       else
          EmacsISearchDirection = SEARCH_BACKWARD;
   }

   declare keySequence = IDE.KeyboardManager.GetKeyboard("Desktop").GetKeySequence("IDE.SearchSearchAgain();");
   EmacsISearchKbd.Assign(keySequence,"editor.EmacsISearchEndAndSearchAgain();");

   IDE.KeyboardManager.Push(EmacsISearchKbd, "Editor", false);
   bPopEditorKeyboard = true;
   EmacsISearchString = "";
   .EmacsISearchDisplayStatus();
}

//
// Performs incremental searching of current buffer.
//
on editor:>EmacsISearch(declare acKey) {

   declare ep = .TopView.Position;
   declare sKey = new String(acKey);
   sKey = sKey.SubString(1, 1);

   if ((IDE.KeyboardManager.KeyboardFlags & 0x03) && // Shift is pressed...
       sKey.Character > 96 &&                        // It's between lower case 'a'
       sKey.Character < 123)                         // and a 'z'
       sKey.Character -= 32;

   // Move the cursor back before the highlight to search again from the
   // begining of the highlight when searching forward.
   if (EmacsISearchDirection == SEARCH_FORWARD)
      ep.MoveRelative(0,-(new String(EmacsISearchString).Length));

   // Add the new key to the search string.
   EmacsISearchString = EmacsISearchString + sKey.Text;

   if (EmacsISearchDirection == SEARCH_BACKWARD)
      ep.MoveRelative(0,new String(EmacsISearchString).Length);

   // Search for the search string...
   // If this fails go back to the previous search string and
   //   search for the last known successful string.
   if (!.EmacsISearchAgain()) {
      declare String CS(EmacsISearchString);
      EmacsISearchString = CS.SubString(0, CS.Length - 1).Text;
      ep.Search(EmacsISearchString, .SearchOptions.CaseSensitive, true, EmacsISearchDirection,BRIEF_RE);
   }

   .SearchOptions.SearchText = EmacsISearchString;

   .EmacsISearchDisplayStatus();
}


on editor:>EmacsISearchBackward() {
   if (EmacsISearchDirection == SEARCH_BACKWARD)
      .EmacsISearchAgain(true);
   else
      {
       EmacsISearchDirection = SEARCH_BACKWARD;
       .EmacsISearchAgain(true);
       .EmacsISearchAgain(true);
      }
   .EmacsISearchDisplayStatus();
}

on editor:>EmacsISearchDisplayStatus() {
   if (EmacsISearchDirection == SEARCH_FORWARD)
      IDE.StatusBar = "I-Search (forward) for:" + EmacsISearchString;
   else
      IDE.StatusBar = "I-Search (backward) for:" + EmacsISearchString;
}


on editor:>EmacsISearchForward() {
   if (EmacsISearchDirection == SEARCH_FORWARD)
      .EmacsISearchAgain(true);
   else
      {
       EmacsISearchDirection = SEARCH_FORWARD;
       .EmacsISearchAgain(true);
       .EmacsISearchAgain(true);
      }
   .EmacsISearchDisplayStatus();
}

on editor:>EmacsISearchAgain(declare bStep) {

   declare ep = .TopView.Position;

   declare result = ep.Search(EmacsISearchString, .SearchOptions.CaseSensitive, true, EmacsISearchDirection,BRIEF_RE);

   if (!result) {
      if (bStep) {
         if (EmacsISearchDirection == SEARCH_FORWARD)
            ep.MoveRelative(0,-(new String(EmacsISearchString).Length));
         else
            ep.MoveRelative(0,new String(EmacsISearchString).Length);

         ep.Search(EmacsISearchString, .SearchOptions.CaseSensitive, true, EmacsISearchDirection,BRIEF_RE);
      }
    IDE.MessageBeep();
   }

 return result;
}


//
// Undoes the last incremental search.
//

on editor:>EmacsISearchBackspace() {

   declare ep = .TopView.Position;

   // Move the cursor back before the highlight to search again from the
   // begining of the highlight when searching forward.
   if (EmacsISearchDirection == SEARCH_FORWARD)
      ep.MoveRelative(0,-(new String(EmacsISearchString).Length));
   else
      ep.MoveRelative(0,new String(EmacsISearchString).Length);

   declare String CS(EmacsISearchString);

   if (CS.Length <= 1) {
      EmacsISearchString = "";
      ep.Move(ep.Row, ep.Column);
   } else {
      EmacsISearchString = CS.SubString(0, CS.Length - 1).Text;
      .EmacsISearchAgain();
   }

   .EmacsISearchDisplayStatus();
}

//
// Ends incremental searching and performs search again.
//
on editor:>EmacsISearchEndAndSearchAgain() {

   IDE.KeyboardManager.SendKeys("{VK_ESCAPE}");
   IDE.EmacsSearchSearchAgain();
}

//
// Processes general keys.
//

on editor:>EmacsISearchKey() {

   declare nLastKeyProcessed = IDE.KeyboardManager.LastKeyProcessed;

   if ((nLastKeyProcessed < 28) || (nLastKeyProcessed > 127)) {

      IDE.KeyboardManager.Pop("Editor");
      bPopEditorKeyboard = false;

      IDE.StatusBar = "I-Search ended";
      return;
   }

   .EmacsISearch(IDE.KeyboardManager.CodeToKey(nLastKeyProcessed));
}

on editor:>EmacsISearchMinus() {
 .EmacsISearch("<->");
}

on editor:>EmacsISearchSpace() {
 .EmacsISearch("< >");
}

on editor:>EmacsExchangePointAndMark() {
   declare ev = .TopView;
   declare ep = ev.Position;

   declare nPointRow = ep.Row;
   declare nPointColumn = ep.Column;

   ev.BookmarkGoto(EMACS_MARK);

   declare nMarkRow = ep.Row;
   declare nMarkColumn = ep.Column;

   ep.Move(nPointRow,nPointColumn);

   ev.BookmarkRecord(EMACS_MARK);

   ep.Move(nMarkRow, nMarkColumn);
}

on editor:>EmacsFindFile() {
}

//
// Move backwards one paragraph.
//
on editor:>EmacsForwardParagraph() {

   declare bBlock = FALSE;
   declare eb = .BlockExists();
   declare ep = .TopView.Position;

   if (eb != NULL) {
      bBlock = TRUE;
   }

   if (ep.Column == 1 && ep.IsWhiteSpace)
      ep.MoveRelative(1,0);
   else
      ep.Move(0,1);

   while (ep.Row != ep.LastRow) {
      if (ep.IsWhiteSpace) {
         break;
      }
      ep.MoveRelative(1,0);
   }

   if (bBlock) {
      eb.End();
   }
}

//
// Using EMACS behavior to align this line with the previous non-blank
// line.
//
on editor:>EmacsIndentPrevious() {

   declare ep = .TopView.Position;

   if (ep.Row != 1) {
      ep.Save();
      ep.Move(ep.Row-1,1);
      ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE);
      declare c = ep.Column;
      ep.Restore();

      if (ep.Column < c)
         {
          declare eb = .BlockExists();
          if (eb == NULL)
             eb = .TopView.Block;
          eb.Save();
          ep.Save();
          eb.Begin();
          ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE);
          eb.End();
          eb.Delete();
          eb.Restore();
          ep.Restore();
          return ep.Align(1);
         }
   }

  return ep.InsertCharacter('\t');
}

on editor:>EmacsKillLine() {
   ess.SetKillBufferContents(.DeleteToEOL(TRUE),.TopView.Position,false);
}

on editor:>EmacsKillLevel() {
}

//
// Move the cursor down one page, extending the block.
//
on editor:>EmacsPageDown() {
   declare ep = .TopView.Position;
   declare eb = .BlockExists();

   if (eb != NULL) {
      ep.Save();
      eb.Save();
   }

   .TopView.PageDown();
   .TopView.Scroll(-1);
   .EmacsLineUp();

   if (eb != NULL) {
      declare row = ep.Row;
      declare column = ep.Column;
      ep.Restore();
      eb.Restore();
      eb.Extend(row, column);
   }
}

//
// Move the cursor up one page, extending the block.
//
on editor:>EmacsPageUp() {
   declare ep = .TopView.Position;
   declare eb = .BlockExists();

   if (eb != NULL) {
      ep.Save();
      eb.Save();
   }

   .TopView.PageUp();
   .TopView.Scroll(1);
   .EmacsLineDown();

   if (eb != NULL) {
      declare row = ep.Row;
      declare column = ep.Column;
      ep.Restore();
      eb.Restore();
      eb.Extend(row, column);
   }
}

//
// Using EMACS behavior mark the current word to the right.
//
on editor:>EmacsForwardWord() {

   declare ep = .TopView.Position;
   declare eb = .BlockExists();
   declare nRow = ep.Row;
   declare nColumn = ep.Column;

   if (eb != NULL) {
      ep.Save();
      eb.Save();
   }

   do {
       ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE | SKIP_STREAM);
       ep.MoveCursor(SKIP_RIGHT | SKIP_NONWORD | SKIP_STREAM);
   } while (!ep.IsWordCharacter && ep.Row != ep.LastRow);

   ep.MoveCursor(SKIP_RIGHT | SKIP_WORD);

   if (eb != NULL) {
      declare row = ep.Row;
      declare column = ep.Column;
      ep.Restore();
      eb.Restore();
      eb.Extend(row, column);
   }
}


on editor:>EmacsOneWindow() {

   declare ev = .TopView;

   if (ev != NULL) {
       declare ew = ev.Window;
       if (ew != NULL) {
         ew.OneView(ev);
       }
   }
}

on editor:>EmacsDeleteView() {

   declare ev = .TopView;

   if (ev != NULL) {
       declare ew = ev.Window;
       if (ew != NULL) {
         ew.RemoveView(ev);
       }
   }
}



//
// Using EMACS behavior cut block.
//
on editor:>EmacsKillRegion() {
   // declare variables.
   declare eb = .BlockExists();
   declare ep = .TopView.Position;

   if (ess.nKeysProcessedYankPop == IDE.KeyboardManager.KeysProcessed - 1) {
      return .EmacsYankPop(true);
   }

   if (eb != NULL) {
      // Cut the region.
      ess.SetKillBufferContents(eb.Text,ep,true);
      RemoveBlock(eb);
   } else {
      declare ev = .TopView;
      eb = ev.Block;

      ep.Save();
      ev.BookmarkGoto(EMACS_MARK);
      eb.Begin();
      ep.Restore();
      eb.End();

      if (eb.Size) {
         ess.SetKillBufferContents(eb.Text,ep,true);
         RemoveBlock(eb);
      }

    ResetBlock(eb);
   }
}

on editor:>EmacsQuotedInsert() {
}

//
// Using EMACS behavior begin marking.
//
on editor:>EmacsSetMark(blockOff) {

   if(blockOff){
      if(.BlockExists()){
         ResetBlock(EXCLUSIVE_BLOCK);
         IDE.StatusBar = "Mark Removed";
      }
      return;
   }

   declare eb = .TopView.Block;
   eb.Reset();
   eb.Begin();
   SetBlockStyle(EXCLUSIVE_BLOCK);
   .TopView.BookmarkRecord(EMACS_MARK);
   eb.Hide = ess.bTransparent;
   IDE.StatusBar = "Mark Set";
}

on editor:>EmacsShrinkWindow() {
   IDE.SetWindowState(SW_RESTORE);
}

on editor:>EmacsShrinkWindowHorizontal() {
}

//
// Change the case of the current word.
//
on editor:>_EmacsSetCase(upperCase) {
   if (.BlockExists())
      ResetBlock(EXCLUSIVE_BLOCK);

   if (!.TopView.Position.IsWordCharacter) {
      .EmacsForwardWord();
      .EmacsBackwardWord();
   }

   BeginBlock(EXCLUSIVE_BLOCK);
   .EmacsForwardWord();
   declare eb = EndBlock();
   if (upperCase)
      eb.UpperCase();
   else
      eb.LowerCase();
   ResetBlock(EXCLUSIVE_BLOCK);
}

//
// Using EMACS behavior upper or lower the case of the current word.
//
on editor:>EmacsUpperWord() {
   ._EmacsSetCase(TRUE);                  // Change word to UPPER CASE
}

on editor:>EmacsLowerWord() {
   ._EmacsSetCase(FALSE);                 // Change word to lower case
}

on editor:>EmacsLineDown() {
   .ModalMoveRelative(1, 0);
   .EmacsSetPreferredColumn();
}

on editor:>EmacsLineUp() {
   .ModalMoveRelative(-1, 0);
   .EmacsSetPreferredColumn();
}

on editor:>EmacsSetPreferredColumn() {

   declare ep = .TopView.Position;
   declare String sLine(ep.Read());
   declare nLineLength = sLine.Length + ep.Column;

   if (ess.nPreferredColumn > ep.Column && ess.nPreferredColumn < nLineLength)
       .ModalMoveRelative(0, ess.nPreferredColumn - ep.Column);
   else if (ess.nPreferredColumn > ep.Column )
       .ModalMoveRelative(0, nLineLength - ep.Column);
}

//
// Cancel current operation.
//
on editor:>EmacsSetKeyAbort(declare acKeyName) {
   if (initialized(acKeyName))
      IDE.KeyboardManager.ScriptAbortKey = acKeyName;
}

on editor:>EmacsSetReplace() {

   declare key = IDE.KeyboardManager.CodeToKey(IDE.KeyboardManager.LastKeyProcessed);

   if (key == "<Shift-Alt-7>" || key == "<Shift-7>") {
    .SearchOptions.RegularExpression = FALSE;
    .SearchOptions.PromptOnReplace = FALSE;
   } else if (key == "<Shift-Alt-5>" || key == "<Shift-5>") {
    .SearchOptions.RegularExpression = FALSE;
    .SearchOptions.PromptOnReplace = TRUE;
   } else if (key == "<Shift-Alt-8>" || key == "<Shift-8>" || key == "<Keypad-*>" ) {
    .SearchOptions.RegularExpression = TRUE;
    .SearchOptions.PromptOnReplace = TRUE;
   }
}

on editor:>EmacsSetSearch() {

   declare key = IDE.KeyboardManager.CodeToKey(IDE.KeyboardManager.LastKeyProcessed);

   if (key == "<Ctrl-Alt-r>" || key == "<Ctrl-r>" || key == "<Shift-Ctrl-r>" || key == "<Shift-Ctrl-Alt-r>") {
      .SearchOptions.GoForward = FALSE;
      .SearchOptions.RegularExpression = TRUE;
   } else {
    .SearchOptions.GoForward = TRUE;
    .SearchOptions.RegularExpression = TRUE;
   }

}

on editor:>EmacsToIndentation() {
   declare ep = .TopView.Position;
   ep.MoveBOL();
   ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE | SKIP_STREAM);
}

//
// Using EMACS behavior swap characters.
//
on editor:>EmacsTransposeCharacters() {
   // Get the line for positioning information.
   declare line = new String(.GetLine());

   // If this number of characters aren't available just end (Two
   // characters and line termination).
   if (line.Length > 4) {
      // declare variables.
      declare ep = .TopView.Position;

      // Save cursor position.
      ep.Save();

      // Check for past EOL position.
      if (ep.Column == line.Length-1)
         ep.MoveRelative(0,-2);
      else
         ep.MoveRelative(0,-1);

      // Get the current position character.
      declare c = ep.Character;

      // Delete the current position character.
      ep.Delete(1);

      // Insert new character after what used to be the next
      // character.
      ep.MoveRelative(0,1);
      ep.InsertCharacter(c);

      // Put back the cursor position
      ep.Restore();
   }
}

//
// Using EMACS behavior swap words.
//
on editor:>EmacsTransposeWords() {
   declare ep = .TopView.Position;
   declare eb = .TopView.Block;

   if (ep.IsWordCharacter && ep.Column != 1)
      .EmacsBackwardWord();

   .EmacsBackwardWord();

   .TopView.BookmarkRecord(BOOKMARK_ID_SYSTEM_ONE);
   BeginBlock(EXCLUSIVE_BLOCK);
   .EmacsForwardWord();
   EndBlock();

   declare txtWord1 = eb.Text;
   eb.Delete();
   .TopView.BookmarkGoto(BOOKMARK_ID_SYSTEM_ONE);

   BeginBlock(EXCLUSIVE_BLOCK);
   .EmacsForwardWord();
   .EmacsBackwardWord();
   EndBlock();

   declare txtWord2 = eb.Text;
   eb.Delete();
   .TopView.BookmarkGoto(BOOKMARK_ID_SYSTEM_ONE);

   BeginBlock(EXCLUSIVE_BLOCK);
   .EmacsForwardWord();
   EndBlock();

   declare txtWord3 = eb.Text;
   eb.Delete();
   .TopView.BookmarkGoto(BOOKMARK_ID_SYSTEM_ONE);

   ep.InsertText(txtWord3);
   ep.Save();
   ep.InsertText(txtWord2);
   ep.InsertText(txtWord1);

   ep.Restore();
   ResetBlock();
}

//
// Using EMACS behavior swap lines.
//
on editor:>EmacsTransposeLines() {
   // declare variables.
   declare ev = .TopView;
   declare eb = ev.Block;
   declare ep = ev.Position;

   // Get previous line and delete it.
   ep.MoveRelative(-1,0);
   declare txt = .GetLine();
   .DeleteLine();

   // EOL only moves to the end of the text.
   ep.MoveEOL();

   // Now move past the new line character.
   ep.MoveCursor(SKIP_RIGHT | SKIP_STREAM);

   // Insert new text.
   ep.InsertText(txt);

   // Position will always be on the second line at the begining.
   ep.MoveBOL();
   ep.MoveRelative(-1,0);
}

//
// Write out block.
//
on editor:>EmacsWriteRegion() {
   declare eb = .BlockExists();

   if (eb != NULL) {
      eb.SaveToFile();
      return;
   }
}

//
// Perform Yank paste operation.
//
on editor:>EmacsYank(declare popBuffer) {
   declare ev = .TopView;
   declare ep = ev.Position;

   if (!initialized(popBuffer)) {
       popBuffer = FALSE;
   }

   ep.Save();
   ep.InsertText(ess.YankKillBufferContents(ep, popBuffer));
   ev.BookmarkRecord(BOOKMARK_ID_SYSTEM_ONE);
   ep.Restore();
   ev.BookmarkRecord(EMACS_MARK);
   ev.BookmarkGoto(BOOKMARK_ID_SYSTEM_ONE);
   ess.nKeysProcessedYankPop = IDE.KeyboardManager.KeysProcessed;
}

//
// Perform YankPop paste operation.
//
on editor:>EmacsYankPop(declare bNoYank) {
   if (ess.nKeysProcessedYankPop == IDE.KeyboardManager.KeysProcessed - 1) {
      // We just yanked or yankPopped, replace what we yanked with the
      // next yank pop.
      declare ev = .TopView;
      declare ep = ev.Position;
      declare eb = ev.Block;

      ResetBlock(EXCLUSIVE_BLOCK);
      eb.End();
      ev.BookmarkGoto(EMACS_MARK);
      eb.Begin();
      RemoveBlock(eb,TRUE);
      if (!initialized(bNoYank))
          .EmacsYank(TRUE);
   }
}

on editor:>ViewActivated(newEditView) {

   // Reset Epsilon kill append.
   ess.nKeysProcessedKill = 0;

   // Check for new clipboard content.
   if (ess.nClipboardToken != newEditView.Position.GetClipboardToken()) {
      ess.nClipboardToken = newEditView.Position.GetClipboardToken();
      declare sText = new String(newEditView.Position.GetClipboard());
      if (sText.Length)
         ess.SetKillBufferContents(sText.Text,NULL,false);
   }

   // Perform existing behaviour
   pass(newEditView);
}

//
// Begins switching buffers
//
declare EmacsSelectBufferKbd = NULL;
declare ebCurrentSelectionBuffer = NULL;

on editor:>EmacsSelectBuffer()
{
   if (EmacsSelectBufferKbd == NULL) {
       EmacsSelectBufferKbd = new Keyboard(FALSE);      // not transparent
       EmacsSelectBufferKbd.Assign("<Down>","editor.EmacsSelectBufferDown();");
       EmacsSelectBufferKbd.Assign("<Up>","editor.EmacsSelectBufferUp();");
       EmacsSelectBufferKbd.Assign("<Enter>","editor.EmacsSelectBufferEnter();");
       EmacsSelectBufferKbd.DefaultAssignment = "editor.EmacsSelectBufferEnd(true);";
   }

        if (initialized(.TopBuffer)) {
                 if (!initialized(.TopBuffer.PriorBuffer()) && !initialized(.TopBuffer.NextBuffer())) {
                          IDE.StatusBar = "Only one buffer.";
                 } else {
                         ebCurrentSelectionBuffer = .TopBuffer;
                         IDE.KeyboardManager.Push(EmacsSelectBufferKbd, "Editor", FALSE);
          bPopEditorKeyboard = true;

                         if (initialized(.TopBuffer.PriorBuffer()))
                                  ebCurrentSelectionBuffer = .TopBuffer.PriorBuffer();
                         IDE.StatusBar = "Select Buffer: " + ebCurrentSelectionBuffer.FullName;
                 }
        } else
                IDE.StatusBar = "No buffers loaded.";
}

on editor:>EmacsSelectBufferDown() {
        declare curView = .TopView;
        if (ebCurrentSelectionBuffer != NULL) {
                ebCurrentSelectionBuffer = ebCurrentSelectionBuffer.NextBuffer();
        }
        IDE.StatusBar = "Select Buffer: " + ebCurrentSelectionBuffer.FullName;
}

on editor:>EmacsSelectBufferUp() {
        if (ebCurrentSelectionBuffer != NULL) {
                ebCurrentSelectionBuffer = ebCurrentSelectionBuffer.PriorBuffer();
        }
        IDE.StatusBar = "Select Buffer: " + ebCurrentSelectionBuffer.FullName;
}

on editor:>EmacsSelectBufferEnter() {
        declare curView = .TopView;

        if (initialized(curView)) {
                curView.Attach(ebCurrentSelectionBuffer);
        IDE.StatusBar = ebCurrentSelectionBuffer.FullName, " Selected.";
        }

  .EmacsSelectBufferEnd();
}

on editor:>EmacsSelectBufferEnd(declare bNoSelection) {

  if (initialized(bNoSelection))
     if (bNoSelection)
        IDE.StatusBar = "Select buffer cancelled.";

  IDE.KeyboardManager.Pop("Editor");
  bPopEditorKeyboard = false;
}
