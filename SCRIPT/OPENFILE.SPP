//----------------------------------------------------------------------------
// cScript
// (C) Copyright 1995, 1997 by Borland International, All Rights Reserved
//
// OPENFILE.SPP
//    Opens a file.
//
// $Revision:   1.27  $
//
//----------------------------------------------------------------------------

import editor;
import IDE;

// mark this module as being a library module
library;

//
// This function is tied to the Editor's local menu command "Open Source"
// There should be a file name at/near the current cursor location.  Fetch it
// into an edit buffer.
//
LoadFileAtCursor(){

   declare quotedFlag = false;
   declare bracketedFlag = false;

   declare ep = editor.TopView.Position;

   // Get the token delimited by whitespace or the whole line...
   declare bFoundDelimiter = false;

   // Will we need to contend with a quote or angle bracket?
   ep.Save();

   declare nCurrentLine = ep.Row;

   if (ep.Search("[<\"]",false,true,SEARCH_BACKWARD,BRIEF_RE)) {
      if (ep.Row == nCurrentLine) {
         bFoundDelimiter = ep.Character;
      } else {
         ep.Restore();
         ep.Save();
      }
   }

   //  Use whitespace as a delimiter
   if (!bFoundDelimiter)
      ep.MoveCursor(SKIP_NONWHITE|SKIP_LEFT);

   declare String sLine(ep.Read());
   ep.Restore();

   // Parse out file name.

   // Look for angle brackets or quotes.
   declare nEndPos = 0;
   declare nStartPos = sLine.Index("<");

   if (!nStartPos) { 
      // We didn't have an angle bracket
      nStartPos = sLine.Index("\"");
      if (!nStartPos) { 
         // We didn't have a quote. Start from the begining of the token.
         nStartPos = 0; 
      } else {  
         // Find the other quote. Strip out first quote.
         quotedFlag = true;
         sLine = sLine.SubString(nStartPos);
         nStartPos = 0;
         nEndPos = sLine.Index("\"") - 1;
      }
   } else { 
      // Try to find the matching angle bracket. Strip out opening bracket.
      sLine = sLine.SubString(nStartPos);
      nStartPos = 0;
      nEndPos = sLine.Index(">") - 1;
      bracketedFlag = true;
   }

   if (!nEndPos) {  
       // Look for whitespace delimeter
       nEndPos = sLine.Index(" ");
       if (!nEndPos)
          nEndPos = sLine.Index("\t");
       if (!nEndPos)
          nEndPos = sLine.Index("\n");
   }

   sLine = sLine.SubString(nStartPos,nEndPos);

   sLine = sLine.Trim();
   sLine = sLine.Trim(TRUE);

   if (sLine.Length) {

      // The new ANSI style header notation allows system header files to be 
      // specified without extension.  As in:
      //   #include <stdio>
      // if we detect an extensionless header file in angle brackets we'll 
      // append a .h so we can find them.
      if(bracketedFlag){
         if(sLine.Index(".") == 0){
            sLine = new String(sLine.Text + ".h");
         }
      }

      SmartFileLoad(sLine.Text, editor.TopBuffer.FullName, quotedFlag);
      return;
   }

  IDE.FileOpen("");
}


// Search the specified path for the file
FindFileOnPath(fileName, path){

   if(fileName == NULL || fileName == "")
      return NULL;

   if(path == NULL || path == "")
      return NULL;

   declare String fullPath(path);
   declare String matchPath;
   declare endPos = 0;
   do{
      endPos = fullPath.Index(";");
      if(endPos){
         matchPath = fullPath.SubString(0, endPos - 1);
         fullPath = fullPath.SubString(endPos);
      }else{
         matchPath = fullPath;
      }

      declare checkThis = matchPath.Text + "\\" + fileName;
      if(IDE.FileExists(checkThis)){
         return checkThis;
      }

   }while(endPos);

   return NULL;
}

SmartFileLoad(declare fileToLoad, declare origFile, declare bQuotedFlag){
   declare foundName = NULL;

   // first, see if we can find a matching node in the current project
   declare prjNode = new ProjectNode(fileToLoad);
   if(prjNode.IsValid){
      foundName = prjNode.InputName;
   }

   // second, look in the current directory first if filename enclosed in quotes
   if (bQuotedFlag) {
      if(foundName == NULL){
         foundName = FindFileOnPath(fileToLoad, ".");
      }
   }

   // Let's use the associated editor to obtain the proper project node.
   declare ProjectNode srcFile(NULL,editor.TopView);

   // Well if it isn't an associated view then... We look using the file name.
   if(!srcFile.IsValid){
      // find a project node to use as a base
      srcFile = new ProjectNode(origFile);
   }

   // The name didn't work so we will use a general purpose node object.
   if(!srcFile.IsValid){
      srcFile = new ProjectNode();
   }

   // third, see if we can find it along the include path
   if(foundName == NULL){
      foundName = FindFileOnPath(fileToLoad, srcFile.IncludePath);
   }

   // fourth, try the source path
   if(foundName == NULL){
      foundName = FindFileOnPath(fileToLoad, srcFile.SourcePath);
   }

   // last chance, look in the current directory if we haven't already
   if (!bQuotedFlag) {
      if(foundName == NULL){
         foundName = FindFileOnPath(fileToLoad, ".");
      }
   }

   if(foundName == NULL){
      // still can't find it - see if user knows
      if(IDE.UseCurrentWindowForSourceTracking){
         editor.NewView(fileToLoad, true);
      }else{
         IDE.FileOpen(fileToLoad);
      }
   }else{
      // open it
      if(IDE.UseCurrentWindowForSourceTracking){
         editor.NewView(foundName);
      }else{
         IDE.DoFileOpen(foundName);
      }
   }
}
