//----------------------------------------------------------------------------
// cScript
// (C) Copyright 1995, 1997 by Borland International, All Rights Reserved
//
// ED_BRIEF.SPP
//    Script component of IDE's Editor Brief emulation.
//    Provides support services for editing environment.
//
// $Revision:   1.16  $
//
//----------------------------------------------------------------------------
// BRIEF Editor.
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Symbol Imports
//----------------------------------------------------------------------------

import IDE;
import editor;
import scriptEngine;
import bFileLoading;
import bPopEditorKeyboard;

//
// Mark this module as being a library module.
//
library;

//----------------------------------------------------------------------------
// Symbol Defines
//----------------------------------------------------------------------------

#define BOOKMARK_ID_SYSTEM_ONE   19
#define BOOKMARK_ID_SYSTEM_TWO   18
#define BOOKMARK_ID_SYSTEM_THREE 17
#define FUNCTION_CONTINUE 0
#define FUNCTION_END      1

//----------------------------------------------------------------------------
// Menu Vectors.
//----------------------------------------------------------------------------

DoIDEFileClose()      { return FUNCTION_CONTINUE; }
DoIDEFileOpen()       { return FUNCTION_CONTINUE; }
DoIDEFilePrint()      { if (!editor.BriefPrint()) return FUNCTION_CONTINUE; return FUNCTION_END; }
DoIDEFileSave()       { if (!editor.Write()) return FUNCTION_CONTINUE; return FUNCTION_END; }
DoIDEFileSaveAs()     { if (!editor.Write()) return FUNCTION_CONTINUE; return FUNCTION_END; }
DoIDEFileSaveAll()    { return FUNCTION_CONTINUE; }
DoIDEEditUndo()       { editor.Undo(); return FUNCTION_END; }
DoIDEEditRedo()       { editor.Redo(); return FUNCTION_END; }
DoIDEEditCut()        { editor.ModalCut(); return FUNCTION_END; }
DoIDEEditCopy()       { editor.ModalCopy(); return FUNCTION_END; }
DoIDEEditPaste()      { editor.Paste(); return FUNCTION_END; }
DoIDEEditClear()      { editor.BriefDelete(); return FUNCTION_END; }
DoIDEEditSelectAll()  { editor.SelectAll(); return FUNCTION_END; }
DoIDEEditBufferList() { return FUNCTION_CONTINUE; }
DoIDESearchFind()     { editor.BriefSetSearch(); return FUNCTION_CONTINUE; }
DoIDESearchReplace(&b) { editor.BriefSetSearch(); b = true; return FUNCTION_CONTINUE; }
DoIDESearchSearchAgain()  { return FUNCTION_CONTINUE; }
DoIDESearchPreviousMessage() { IDE.ViewMessage("&Buildtime", true); return FUNCTION_CONTINUE; }
DoIDESearchNextMessage()     { IDE.ViewMessage("&Buildtime", true); return FUNCTION_CONTINUE; }

//----------------------------------------------------------------------------
// Methods.
//----------------------------------------------------------------------------

//
// Used to autoload the Brief Emulation specific Methods.
//
briefEmulation(bUnassign) {

   IDE.KeyboardManager.ScriptAbortKey = "<Escape>";
   IDE.KeyboardManager.ProcessKeyboardAssignments(scriptEngine.StartupDirectory+IDE.KeyboardAssignmentFile,bUnassign);

   if (bUnassign) {
      print "BRIEF emulation unloaded.";
      scriptEngine.Unload(typeid(module()));
   } else {
      print "BRIEF emulation enabled.";
   }
}

//
// Uses BRIEF specific behavior to determine backspace.
//
on editor:>BriefBackspace() {
   declare ev = .TopView;
   declare ep = ev.Position;

   if (ep.Column > 1) {
       declare eb = .BlockExists();
       if (eb) {
          ep.Save();
          ep.Move(eb.StartingRow,eb.StartingColumn);
          ev.BookmarkRecord(BOOKMARK_ID_SYSTEM_ONE);
          ep.Move(eb.EndingRow,eb.EndingColumn);
          ev.BookmarkRecord(BOOKMARK_ID_SYSTEM_TWO);
          ep.Restore();
          .BackspaceDelete(1);
          ResetBlock();
          ev.BookmarkGoto(BOOKMARK_ID_SYSTEM_ONE);
          BeginBlock();
          ev.BookmarkGoto(BOOKMARK_ID_SYSTEM_TWO);
          EndBlock();
       }
    else
       .BackspaceDelete(1);
   }
}

//
// Uses BRIEF specific behavior to determine indenting position.
//
on editor:>BriefDelete() {
   declare eb = .BlockExists();

   if (eb != NULL) {
      if (eb.Size != 0) {

          declare ep = .TopView.Position;
                         declare nRestoreColumn = 0;

                         if (eb.Style == LINE_BLOCK) {
                                  nRestoreColumn = ep.Column;
                         }

                         RemoveBlock(eb,TRUE);

                         if (nRestoreColumn)
                                  ep.Move(0,nRestoreColumn);

          IDE.StatusBar = "Block deleted";
          return;
         }
   }
   return .DeleteChar(1);
}

//
// Uses BRIEF specific behavior to determine indenting position.
//
on editor:>BriefDeleteWord(declare nLeft) {

        declare bBlock = FALSE;
        declare ev = .TopView;
        declare ep = ev.Position;
        declare eb = .BlockExists();

        if (eb != NULL) {
                 bBlock = TRUE;
                 eb.Save();
        } else
                 eb = ev.Block;

        ev.BookmarkRecord(BOOKMARK_ID_SYSTEM_ONE);

        if (initialized(nLeft)) {
                 BeginBlock(EXCLUSIVE_BLOCK);
                 .BriefBackwardWord();
                 eb.Delete();
        } else {
                 BeginBlock(EXCLUSIVE_BLOCK);

       declare bStartedAtEnd = (ep.Character == 13);

       if (ep.IsWordCharacter)
          ep.MoveCursor(SKIP_RIGHT | SKIP_WORD);
       else if (ep.IsSpecialCharacter)
          ep.MoveCursor(SKIP_RIGHT | SKIP_SPECIAL);

       if (bStartedAtEnd)
         ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE | SKIP_STREAM);
       else
         ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE);

       EndBlock();
       eb.Delete();
        }

        ResetBlock();
        ev.BookmarkGoto(BOOKMARK_ID_SYSTEM_ONE);

        if (bBlock == TRUE) {
                 eb.Restore();
        }
}

on editor:>BriefForwardWord() {

   declare eb = .BlockExists();
   declare ep = .TopView.Position;

   if (eb != NULL) {
       eb.Save();
       ep.Save();
   }

   if (ep.IsWordCharacter)
      ep.MoveCursor(SKIP_RIGHT | SKIP_WORD);
   else if (ep.IsSpecialCharacter)
      ep.MoveCursor(SKIP_RIGHT | SKIP_SPECIAL);

   ep.MoveCursor(SKIP_RIGHT | SKIP_WHITE | SKIP_STREAM);

   if (eb != NULL) {
       declare nRow = ep.Row;
       declare nColumn = ep.Column;
       ep.Restore();
       eb.Restore();
       eb.Extend(nRow, nColumn);
   }
}


on editor:>BriefBackwardWord() {

   declare eb = .BlockExists();
        declare ep = .TopView.Position;

   if (eb != NULL) {
       eb.Save();
       ep.Save();
   }

   ep.MoveCursor(SKIP_LEFT | SKIP_WHITE | SKIP_STREAM);

   declare nColumn = ep.Column;

   ep.MoveCursor(SKIP_LEFT | SKIP_SPECIAL);

   if (nColumn == ep.Column)
       ep.MoveCursor(SKIP_LEFT | SKIP_WORD);

        if (eb != NULL) {
                 declare nRow = ep.Row;
                 declare nColumn = ep.Column;
                 ep.Restore();
                 eb.Restore();
                 eb.Extend(nRow,nColumn);
        }
}

//
// Split line at current cursor location and continue editing.
//
on editor:>BriefOpenLine() {
   .ModalMoveEOL();
   .TopView.Position.InsertCharacter('\r');
}

//
// Uses BRIEF specific behaviour to open a new file for editing.
//
on editor:>BriefEditFile() {

        declare sFileName = new 
         String(ContextSensitiveFileDialog("EditFile", "File:", "*.*"));

        if (sFileName.Text != "" && IDE.IsLegalFileName(sFileName.Text)) {

            declare eb = new EditBuffer(sFileName.Text);

            if (eb == NULL || eb.IsValid == FALSE) {
                IDE.ReportError("Unable to create new edit buffer");
                return;
            }

            if (initialized(.TopView)) {
                declare ev = .TopView;
                if (ev != NULL && ev.IsValid == TRUE)
                ev.Attach(eb); // replace the existing view
            } else {
                declare EditWindow ew(eb); // create a new Editor Window
                ew.Activate();             // and activate it...
            }
        }
}

//
// Uses BRIEF specific behaviour to print.
//
on editor:>BriefPrint() {
   declare eb = .BlockExists();

   if (eb != NULL) {
      eb.Print();
      return true;
   }

   IDE.StatusBar = "No marked block.";
   return false;
}

//
// Repeat the last search/replace operation.
//
on editor:>BriefReplaceAgain() {

   declare eb = .BlockExists();
        declare ep = .TopView.Position;

   ep.Save();
   if (eb != NULL)
      eb.Save();
   ep.SearchOptions.Copy(.SearchOptions);
   ep.ReplaceAgain();
   ep.Restore();
   if (eb != NULL)
      eb.Restore();
}

//
// Uses BRIEF specific behavior to determine indenting position.
//
declare gbBriefSSBypass = false;

on editor:>BriefSetSearch() {

   if (!gbBriefSSBypass) {
      .SearchOptions.GoForward = true;
   }

   gbBriefSSBypass = false;
}

on editor:>BriefSearch(declare bReplace) {

   declare km = IDE.KeyboardManager;
   declare key = km.CodeToKey(km.LastKeyProcessed);

   if (key == "<Alt-F5>" || key == "<Alt-F6>" ) {
       .SearchOptions.GoForward = false;
       gbBriefSSBypass = true;
   }

 if (bReplace) {
    declare eb = .BlockExists();
         declare ep = .TopView.Position;

         ep.Save();
    if (eb != NULL)
       eb.Save();
    IDE.SearchReplace();
         ep.Restore();
    if (eb != NULL)
       eb.Restore();

 } else
    IDE.SearchFind();
}

//
// Uses BRIEF specific behavior to determine indenting position.
//
on editor:>BriefSmartTab() {

   declare eb = .BlockExists();
   if (eb != NULL) {
      eb.Indent(.Options.BlockIndent);
   } else if (.Options.BufferOptions.InsertMode)
      .TopView.Position.InsertCharacter('\t');
   else
      .TopView.Position.Tab(1);
}

//
// Uses BRIEF specific behavior to determine outdenting position.
//
on editor:>BriefSmartBackTab() {
   declare eb = .BlockExists();
   if (eb != NULL) {
      eb.Indent(-(.Options.BlockIndent));
   } else
      .TopView.Position.Tab(-1);
}

//
// Copy currently selected block, switch to single line block mode if
// needed.
//
on editor:>ModalCopy(declare append) {
   declare eb = .BlockExists();
   declare msg;
   if (eb == NULL) {
      eb = ToggleBlockStyle(LINE_BLOCK);
      msg = "Line copied to scrap";
   } else
      msg = "Block copied to scrap";

   CopyBlock(eb,append);

   IDE.StatusBar = msg;
}

//
// Cut currently selected block, switch to single line block mode if
// needed.
//
on editor:>ModalCut() {
   // declare variables.
   declare eb = .BlockExists();
   declare ep = .TopView.Position;
   declare nRestoreColumn = 0;
   declare msg = "Block deleted to scrap";

   if (eb == NULL) {
      nRestoreColumn = ep.Column;
      eb = ToggleBlockStyle(LINE_BLOCK);
      msg = "Line cut to scrap";
   }

   RemoveBlock(eb);

   if (nRestoreColumn)
       ep.Move(0,nRestoreColumn);

   IDE.StatusBar = msg;
}

//
// Uses BRIEF specific behavior to determine next end key position.
//
declare __LastEndKeysProcessed;
declare __LastEndKeysProcessedStep;

on editor:>ModalEnd() {

   declare keyCnt = IDE.KeyboardManager.KeysProcessed;

   if (__LastEndKeysProcessed + 1 == keyCnt){// We are still in the sequence.
      __LastEndKeysProcessed++;
      __LastEndKeysProcessedStep++;
   } else {                                 // Something else was pressed.
      __LastEndKeysProcessed=keyCnt;
      __LastEndKeysProcessedStep=1;
   }

   switch(__LastEndKeysProcessedStep) {
   case 1:
      .ModalMoveEOL();
      break;
   case 2:
      .ModalMoveViewBottom();
      break;
   case 3:
      .ModalMoveEOF();
      break;
   }
}

//
// Uses BRIEF specific behavior to determine next home key position.
//
declare __LastHomeKeysProcessed;
declare __LastHomeKeysProcessedStep;

on editor:>ModalHome() {
   declare keyCnt = IDE.KeyboardManager.KeysProcessed;

   if (__LastHomeKeysProcessed + 1 == keyCnt){// We are still in the sequence.
      __LastHomeKeysProcessed++;
      __LastHomeKeysProcessedStep++;
   } else {                                 // Something else was pressed.
      __LastHomeKeysProcessed=keyCnt;
      __LastHomeKeysProcessedStep=1;
   }

   switch(__LastHomeKeysProcessedStep) {
   case 1:
      .ModalMoveBOL();
      break;
   case 2:
      .ModalMoveViewTop();
      break;
   case 3:
      .ModalMoveBOF();
      break;
   }
}

//
// Get the direction key for new view.
//

declare kbdCreateView = NULL;

on editor:>BriefCreateView() {
   if (kbdCreateView == NULL) {
      kbdCreateView = new Keyboard(FALSE);
                kbdCreateView.Assign("<Left>","editor.BriefCreateViewSelect(LEFT);",ASSIGN_IMPLICIT_KEYPAD);
                kbdCreateView.Assign("<Right>","editor.BriefCreateViewSelect(RIGHT);",ASSIGN_IMPLICIT_KEYPAD);
                kbdCreateView.Assign("<Up>","editor.BriefCreateViewSelect(UP);",ASSIGN_IMPLICIT_KEYPAD);
                kbdCreateView.Assign("<Down>","editor.BriefCreateViewSelect(DOWN);",ASSIGN_IMPLICIT_KEYPAD);
                kbdCreateView.Assign("<Escape>","editor.BriefCreateViewSelect();");
      kbdCreateView.DefaultAssignment = ";";
   }

   IDE.KeyboardManager.Push(kbdCreateView, "Editor", FALSE);
   bPopEditorKeyboard = true;
   IDE.StatusBar = "Select side for new view (use cursor keys).";
}

on editor:>BriefCreateViewSelect(declare direction) {

   if (initialized(direction)) {
      editor.CreateView(direction);
      IDE.StatusBar = "";
   } else
      IDE.StatusBar = "Command cancelled.";

   IDE.KeyboardManager.Pop("Editor");
   bPopEditorKeyboard = false;
}

on editor:>BriefZoomPaneToggle() {
   if (initialized(.TopView)) {
       if (.TopView.IsZoomed)
           .TopView.IsZoomed = false;
       else
           .TopView.IsZoomed = true;
   }

}
