//----------------------------------------------------------------------------
// cScript
// (C) Copyright 1995 by Borland International, All Rights Reserved
//
// FILTERS.SPP
//
// The scripts contained in this module process output from the IDE's
// Transfer system.  They are called from the TransferOutputExists()
// handler found in the FILTSTUB module.
//
// The scripts are passed a TransferOutput object from which they are
// responsible for extracting the tool's raw output from the tool.  They
// then perform any necessary formatting for the message and call the
// MessageCreate method on the IDE object in order to have the messages
// added to the IDE's Message Database.
//
// The scripts should return a non-zero error code if an error is detected
// during processing of the raw data.  Otherwise the scripts should return 0.
//
// Processing scripts are:
//     ParseGenericMessages()
//     ParseGrepMessages()
//     ParseHelpCompilerMessages()
//     ParseResourceCompilerMessages()
//     ParseAssemblerMessages()
//     ParseFilenameMessages()
//
// $Revision:   1.22  $
//
//----------------------------------------------------------------------------

import IDE;

// mark this module as being a library module
library;

//
// Handle messages of the form:
//    MessageText
// where:
//    MessageText is any output to standard IO
//
// Messages of any kind can be imported from transfer tools
// but no file and line number information will be available
//
ParseGenericMessages(output){
   declare input;          // The raw text output.
   declare line;           // The input string that is processed.
   declare p;              // A "pointer" into line.
   declare fileName;       // The message filename.
   declare fileRow;        // The message line number.
   declare msgType;        // The message type.
   declare message;        // The message.

   // Read output text until there is no more.
   while((input = output.ReadLine()) != NULL){
      // Convert the raw text into a String object.
      line = new String(input);

      // Remove leading whitespace and skip empty lines
      if(input == "" || line.Trim(1).Length <= 1){
         continue;
      }

      msgType = INFORMATION;

      // Move past the beginning.
      p = line.Index(" ");

      // Ensure that there is some useful information.
      if(p == 0){
         continue;
      }

      fileName = "";
      fileRow  = 1;

       // Post the message to the IDE message database.
       IDE.MessageCreate(NULL, "transfer", msgType, 0,
                          NULL, 0, 0, line.Text, 0, 0);
   }

   return 0;
}

//
// Handle messages of the form:
//    [path]Filename
// where:
//    [path]Filename is any output to standard IO
//
// This filter can be used with tools that output filenames
// such as the DOS "dir /s/b" command
//
ParseFilenameMessages(output){
   declare input;          // The raw text output.
   declare line;           // The input string that is processed.
   declare fileName;       // The message filename.
   declare msgType;        // The message type.
   declare message;        // The message.
   declare parentMsg;      // The message header.

   // Create a message header using the transfer provider

   msgType  = INFORMATION;
   parentMsg = IDE.MessageCreate("Directory", "transfer", msgType, 0, NULL,
            0, 0, "Output processed by "+output.Provider+" filter.", 0, 0);

   // Read output text until there is no more.
   while((input = output.ReadLine()) != NULL){
      // Convert the raw text into a String object.
      line = new String(input);

      // Remove leading whitespace and skip empty lines
      if(input == "" || line.Trim(1).Length <= 1){
         continue;
      }

      // Ensure that there is some useful information.
      if(line == 0){
        continue;
      }

      fileName = line.Text;
      message  = fileName;

      // Post the message to the IDE message database.  Use the initial
      // MessageCreate return value, parentMsg, to group messages.

      IDE.MessageCreate("Directory", "transfer", msgType, parentMsg,
                   fileName, 1, 1, message, 0, 0);
   }

   return 0;
}

//
// Handle messages of the form:
//    Type Filename:#### MessageText
// where:
//    Type is one of: "Error", "Warning", "Fatal"
//    Filename is the name of the source module
//    #### is a number representing the line in the source module
//
// Messages with this format are generated by most Borland Tools
//
ParseBorlandMessages(output){
   declare input;          // The raw text output.
   declare line;           // The input string that is processed.
   declare p;              // A "pointer" into line.
   declare fileName;       // The message filename.
   declare fileRow;        // The message line number.
   declare msgType;        // The message type.
   declare message;        // The message.

   // Read output text until there is no more.
   while((input = output.ReadLine()) != NULL){
      // Convert the raw text into a String object.
      line = new String(input);

      // Remove leading whitespace and skip empty lines
      if(input == "" || line.Trim(1).Length <= 1){
         continue;
      }

      // Check for lines that begin with Error or Warning or Fatal.
      if(line.SubString(0, 5).Text == "Error"){
         msgType = ERROR;
      }else if(line.SubString(0, 10).Text == "Stub error"){
         // Borland App 32RTM stub gave an error, quit and cry fatal
         IDE.MessageCreate(NULL, "transfer", FATAL, output.MessageId,
                           "", 1, 1, line.Text, 0, 0);
         return 0;
      }else if(line.SubString(0, 5).Text == "Fatal"){
         msgType = FATAL;
      }else if (line.SubString(0, 7).Text == "Warning"){
         msgType = WARNING;
      }else{
         msgType = INFORMATION;
      }

      // If line begins with Error or Warning or Fatal we want
      // to process it.
      if(msgType != INFORMATION){
         // Move past the beginning.
         p = line.Index(" ");

         // Ensure that there is some useful information.
         if(p == 0){
            continue;
         }

         // Extract a filename and line number.
         if(line.SubString(p - 2, 1).Text == ":"){
               fileName = "";
               fileRow  = 1;
         }else{
            // Move to the filename.
            line = line.SubString(p);

            // Extract the filename.
            if((p = line.Index(" ")) != 0){
               fileName = line.SubString(0, p).Text;

               // Move to the line number.
               line = line.SubString(p);

               // Extract the line number.
               if((p = line.Index(":")) != 0){
                  fileRow = line.SubString(0, p).Integer;
               }else{
                  fileRow = 1;
               }
            }else{
               fileName = "";
               fileRow  = 1;
            }
         }

         // Post the message to the IDE message database.
         IDE.MessageCreate(NULL, "transfer", msgType, output.MessageId,
                fileName, fileRow, 1, line.SubString(p).Text, 0, 0);
      }
   }

   return 0;
}

//
// Handle messages of the form:
//    File Filename:
//    #### MessageText
// where:
//    Filename is the name of the source module
//    #### is a number representing the line in the source module
//
// We expect to start with a message of the form "File Filename:" which
// serves as an indicator of the "current filename".  This file will then
// be used as the source for subsequent messages of the form
// "#### MessageText".
//
// Messages with this format are generated by most Borland's Grep
//
ParseGrepMessages(output){
   declare input;          // The raw text output.
   declare line;           // The input string that is processed.
   declare p;              // A "pointer" into line.
   declare fileName = "";  // The message filename.
   declare fileRow;

   // Read output text until there is no more.
   while((input = output.ReadLine()) != NULL){
      // Convert the raw text into a String object.
      line = new String(input);

      // Remove leading whitespace and skip empty lines
      if(input == "" || line.Trim(1).Length <= 1){
         continue;
      }

      // If there are no file matches, don't process output.
      if(line.SubString(0, 18).Text == "No files matching:"){
         continue;
      }

      // Find the first blank in the line.
      p = line.Index(" ");

      // Extract the filename if present.
      if(line.SubString(0, 5).Text == "File "){
         fileName = line.SubString(p,
                    line.Index(":", SEARCH_BACKWARD) - p - 1).Text;
      }else{
         if(p){
            fileRow = 1;

            // Skip blank lines lines of the form "N lines match".
            if(line.SubString(0, 11).Text != "lines match" &&
                line.Trim(1).Length > 1){
               // Extract the line number.
               fileRow = line.SubString(0, p - 1).Integer;

               line = line.SubString(p);

               // Post the message to the IDE message database.
               IDE.MessageCreate("&Grep", "transfer", INFORMATION,
                  0, fileName, fileRow, 1,
                  line.SubString(p).Text, 0, 0);
            }
         }
      }
   }

   return 0;
}


//
// Handle messages of the form:
//    Type @@@@: line...#### of Filename : MessageText
// where:
//    Type is one of: "Error", "Warning"
//    @@@@ is a Microsoft internal error code (like anyone knows/cares)
//    #### is a number representing the line in the source module
//    Filename is the name of the source module
//
// Messages with this format are generated by the Microsoft Help Compiler
ParseHelpCompilerMessages(output){
   declare input;          // The raw text output.
   declare line;           // The input string that is processed.
   declare p;              // A "pointer" into line.
   declare fileName;       // The message filename.
   declare fileRow;        // The message line number.
   declare msgType;        // The message type.
   declare message;        // The message.

   // Read output text until there is no more.
   while((input = output.ReadLine()) != NULL){
      // Convert the raw text into a String object.
      line = new String(input);

      // Remove leading whitespace and skip empty lines
      if(input == "" || line.Trim(1).Length <= 1){
         continue;
      }

      if(line.SubString(0, 5).Text == "Error"){
         msgType = ERROR;
      }else if(line.SubString(0, 7).Text == "Warning"){
         msgType = WARNING;
      }else{
         msgType = INFORMATION;
      }

      if(msgType != INFORMATION){
         p = line.Index(":");

         if(p){
            line = line.SubString(p);

            if(line.SubString(0, 5).Text == " line"){
               line = line.SubString(5);

               // Skip over any '.' characters.
               while(line.SubString(0, 1).Text == "."){
                  line = line.SubString(1);
               }

               if(p = line.Index(" of")){
                  fileRow = line.SubString(0, p - 1).Integer;

                  line = line.SubString(p + 3);

                  p = line.Index(" : ");

                  fileName = line.SubString(0, p - 1).Text;
                  message  = line.SubString(p + 2).Text;
               }else{
                  fileName = "";
                  fileRow  = 0;
                  message  = line.Text;
               }
            }else{
               fileName = "";
               fileRow  = 1;
               message  = line.Text;
            }

            // Post the message to the IDE message database.
            IDE.MessageCreate(NULL, "transfer", msgType, output.MessageId,
                  fileName, fileRow, 1, message, 0, 0);
                 }
      }
   }

   return 0;
}


//
// Handle messages of the form:
//    Filename(####) : error @@@@ : MessageText
// where:
//    Filename is the name of the source module
//    #### is a number representing the line in the source module
//    @@@@ is a Microsoft internal error code (like anyone knows/cares)
//
// Messages with this format are generated by Microsoft Resource Compiler
//
ParseResourceCompilerMessages(output){
   declare input;          // The raw text output.
   declare line;           // The input string that is processed.
   declare p;              // A "pointer" into line.
   declare q;              // A "pointer" into line.
   declare fileName;       // The message filename.
   declare fileRow;        // The message line number.
   declare message;        // The message.

   // Read output text until there is no more.
   while((input = output.ReadLine()) != NULL){
      // Convert the raw text into a String object.
      line = new String(input);

      // Remove leading whitespace and skip empty lines
      if(input == "" || line.Trim(1).Length <= 1){
         continue;
      }

      // If line starts with "Microsoft" or "Copyright", it's not
      // an error line.
      if(line.SubString(0, 9).Text == "Microsoft"       ||
         line.SubString(0, 9).Text == "Copyright"){
         continue;
      }

      // If there is a '(' in the line, the line may contain a line number.
      p = line.Index("(");

      // If there is a line number, a ':' must be present
      q = line.SubString(p).Index(":");

      if(p && q){
         // Extract the file name.
         fileName = line.SubString(0, p - 1).Text;

         // Extract the line number.
         fileRow = line.SubString(p, line.Index(")") - 2).Integer;

         // Extract the message.
         message = line.SubString(p + q).Text;
      }else{
         fileName = "";
         fileRow  = 1;
         message  = line.Text;
      }

      // Post the message to the IDE message database.
      IDE.MessageCreate(NULL, "transfer", INFORMATION, output.MessageId,
         fileName, fileRow, 1, message, 0, 0);
   }

   return 0;
}


//
// This is a helper script called from ParseAssemblerMessages to handle output from
// Assemblers other than TASM.  It returns TRUE if line is a recognized,
// FALSE otherwise.
//
// Handle messages of the form:
//
//    filename.typ(####): error A@@@@: error message
//    filename.typ(####): warning A@@@@: warning message
//
// where:
//
//    #### is a number representing the line in the source module
//    @@@@ is a Microsoft internal error code (like anyone knows/cares)
//
// Messages with this format are generated by the Microsoft Assembler and
// by SLR's OptAsm.
//
ProcessNonTasmLine(output, line){
   declare fileName;       // The message filename.
   declare fileRow;        // The message line number.
   declare message;        // The message.
   declare p;              // A "pointer" into line.

   if((p = line.Index("(")) != 0){
      // Extract the file name.
      fileName = line.SubString(0, p - 1).Text;

      line = line.SubString(p);

      if((p = line.Index(")")) != 0){
         // Extract the file line number.
         if((fileRow = line.SubString(0, p - 1).Integer) != 0){
            line = line.SubString(p).Trim(1);

            if((p = line.Index(":")) == 0){
               return FALSE;
            }

            line = line.SubString(p).Trim(1);

            // Check for warning or error text from MASM.
            if(line.SubString(0, 7).Text == "warning"){
               if(line.SubString(0, 5).Text == "error"){
                  return FALSE;      // Not error or warning, not MASM line.
               }
            }

            // Extract the message.
            message = line.Trim(1).Text;

            // Post the message to the IDE message database.
            IDE.MessageCreate(NULL, "transfer", INFORMATION, output.MessageId,
                  fileName, fileRow, 1, message, 0, 0);

            return TRUE;      // MASM/OPTASM line.
         }
      }
   }

   return FALSE;      // Not a MASM/OPTASM line.
}

//
// This is a helper script called from ParseAssemblerMessages to handle output from
// TASM.  It returns TRUE if line is a Turbo Assembler line, FALSE otherwise.
//
// Handle messages of the form:
//    Type Filename (####) MessageText
// where:
//    Type is one of: "**Error**", "*Warning*", "**Fatal**"
//    Filename is the name of the source module
//    #### is a number representing the line in the source module
//
// Messages with this format are generated by the Borland Turbo Assembler
//
ProcessTasmLine(output, line){
   declare fileName;       // The message filename.
   declare fileRow;        // The message line number.
   declare message;        // The message.
   declare msgType;        // The message type.
   declare p;              // A "pointer" into line.

   if(line.SubString(0, 10).Text == "**Fatal** "){
      msgType = FATAL;
   }else if(line.SubString(0, 10).Text == "**Error** "){
      msgType = ERROR;
   }else if(line.SubString(0, 10).Text == "*Warning* "){
      msgType = WARNING;
   }else{
      msgType = INFORMATION;
   }

   if(msgType == INFORMATION){
      return TRUE;  // just skip for now
   }

   fileName = "";

   // Skip over fatal tasm text.
   line = line.SubString(10);

   // Find the opening '('.
   if((p = line.Index("(")) != 0){
      // Extract the filename.
      fileName = line.SubString(0, p - 1).Text;

      line = line.SubString(p);

      // Find the closing ')'.
      if((p = line.Index(")")) != 0){
         // Extract the file line number.
         if((fileRow = line.SubString(0, p - 1).Integer) != 0){
            line = line.SubString(p+1, line.Length());
            // Extract the message.
            message = line.Text;
            // Post the message to the IDE message database.
            IDE.MessageCreate(NULL, "transfer", msgType, output.MessageId,
                    fileName, fileRow, 1, message, 0, 0);

            return TRUE;      // A TASM line.
         }
      }
   }else{
      // Fatal error, no line number or filename.

      fileName = "";
      fileRow  = 1;
      message  = line.Trim(1).Text;

      // Post the message to the IDE message database.
      IDE.MessageCreate(NULL, "transfer", FATAL, output.MessageId, fileName,
            fileRow, 1, message, 0, 0);

      return TRUE;      // A TASM line.
   }

   return FALSE;      // Not a TASM line.
}

//
// ParseAssemblerMessages handles messages that look like they were generated by an
// assembler.  It determines which assembler's format the message is in
// and calls the appropriate script to handle the details.
ParseAssemblerMessages(output){
   declare filter = "NONE";        // The function to do the filtering.
   declare input;                  // The raw text output.
   declare line;                   // The input string that is processed.

   // Read output text until there is no more.
   while((input = output.ReadLine()) != NULL){
      // Convert the raw text into a String object.
      line = new String(input);

      // Remove leading whitespace and skip empty lines
      if(input == "" || line.Trim(1).Length <= 1){
         continue;
      }

      if(filter == "TASM"){
         if(ProcessTasmLine(output, line) != 1){
            return  1;
         }
      }else if(filter == "NONTASM"){
         if(ProcessNonTasmLine(output, line) != 1){
            return  1;
         }
      }else{
         // Check for a TASM style line.
         if(ProcessTasmLine(output, line)){
            filter = "TASM";
         }else{
            // Check for a MASM or OPTASM style line.
            if(ProcessNonTasmLine(output, line)){
               filter = "NONTASM";
            }
         }
      }
   }

   return 0;
}
