//--------------------------------------------------------------------------
// Object Scripting
// Copyright (c) 1996 by Borland International, All Rights Reserved
//
// APIEXP.SPP: API Expander. Expands current word in editor to the matching
//   Windows API or C RTL signiture. Provides selection list if seed string
//   has multiple matches. If the match is an RTL member, API Expander can
//   almost always indicate if the corresponding header file needs to be
//   included in the source file.
//
// USE: Run with cursor on or just to the right of the word to expand.
//   Matching is case-sensitive.
//
// FILES: APIEXP.DAT, MSG.SPP, FILE.SPP, MISC.SPP
//
// NOTES: All apiexp.* files must reside in the same directory. The DAT file
//   does not currently contain every Windows API.
//--------------------------------------------------------------------------
print "apiexp.spp";

//
// IDE imports.
//
import IDE;
import scriptEngine;
import editor;

//
// Load support module(s).
//
if (!scriptEngine.IsLoaded("msg.spp")) scriptEngine.Load("msg.spp");
if (!scriptEngine.IsLoaded("file.spp")) scriptEngine.Load("file.spp");
if (!scriptEngine.IsLoaded("misc.spp")) scriptEngine.Load("misc.spp");

Msg = new TMsg();  // Message object.

//
// Create an expander object.
//
Expander = new TExpander(GetModuleDir("apiexp.spp") + "\\apiexp.dat", TRUE);

apiexp()
{
  // Execute the expander object to expand the current word.
  //
  Expander.Expand();
}

//
// class TExpander
// ~~~~~ ~~~~~~~~~
// TExpander encapsulates word-expansion functionality.
//
class TExpander(dataFile, caseSensitive) {
  declare Matches;
  declare CaseSensitive = caseSensitive;
  declare CurView;
  declare EdPos;
  declare EdBlk;

  // Instantiate a list object for selection of multiple matches.
  //
  declare SelList = new ListWindow(50, 50, 200, 550,
                                   "Multiple matches found.", FALSE, FALSE,
                                   NULL);

  // Instantiate a file object for the data file and make sure it exists.
  //
  declare File = new TFlatFile(dataFile);
  if (!File.IsValid()) {
    Msg.Error("The data file is not valid.");
  }

  //
  // Returns the word the cursor is on, or just to the right of. 
  // Leaves seed as the current block with the cursor at the beginning.
  //
  GetSeed()
  {
    EdPos.MoveCursor(SKIP_NONWHITE | SKIP_RIGHT);
    EdBlk.End();
    EdPos.MoveCursor(SKIP_LEFT);
    EdBlk.Begin();
    return EdBlk.Text;    
  }

  //
  // Expands the word the cursor is on, or just to the right of. 
  //
  Expand()
  {
    // Validate the buffer.
    //
    if (!editor.TopView.IsValid) {
      Msg.Info("You must have an open buffer for expansion.");
      return;
    }

    // Assign edit objects.
    //
    CurView = editor.TopView;
    EdPos = CurView.Position;
    EdBlk = CurView.Block;

    // Get the seed word.
    //
    declare seed = GetSeed();
    if (seed == "") {
      Msg.Warn("There is no seed word to expand.");
      return;
    }

    // Get the matches. Always search at the beginning of a data line.
    //
    File.EdPos.Move(1, 1);
    declare matches = 0;
    Matches = new array[];
    declare sLine = new String();
    while (File.EdPos.Search("^" + seed, CaseSensitive, TRUE, NULL, IDE_RE)) {
      File.EdPos.MoveBOL();
      sLine.Text = File.EdPos.Read();
      sLine = sLine.Trim();
      Matches[matches] = sLine.Text;
      File.EdPos.MoveEOL();
      matches++;
    }

    // Respond to number of matches.
    //
    switch (matches) {
      case 0:
        Msg.Info("No expansion match.");
        break;

      case 1:  // Single match.
        InsertMatch(sLine.Text);
        break;

      default:  // Multiple matches.
        BuildSelectionList();
    }
  }

  //
  // Inserts the match in the buffer. Performs header checking if the match
  // is an RTL item.
  //
  InsertMatch(line)
  {
    // If match is from the RTL, remove the header file info.
    //
    declare sLine = new String(line);
    declare position = sLine.Index(".h");
    declare headerFile;
    if (position) {
      headerFile = sLine.SubString(sLine.Index(";")).Text;
      sLine = sLine.SubString(0, sLine.Index(";"));
    }

    // Insert the match, positioning the caret at the open parens.
    //
    EdBlk.Delete();

    EdPos.InsertText(sLine.Text);
    declare openParens = sLine.Index("(");
    EdPos.MoveRelative(NULL, openParens - sLine.Length);

    // If RTL item, attempt to see if the needed header is included.
    //
    if (position) {
      declare edBuf = new EditBuffer(CurView.Buffer.FullName, TRUE, TRUE);
      edBuf.Position.Move(1, 1);

      if (!edBuf.Position.Search("include*" + headerFile, FALSE, TRUE,
                                 SEARCH_FORWARD, BRIEF_RE)) {
        Msg.Info("You need to include " + headerFile);
      }
      edBuf.Destroy();
    }
  }

  //
  // Run the multiple matches list. 
  //
  BuildSelectionList()
  {
    SelList.Hidden = TRUE;
    SelList.Execute();
    SelList.Clear();
    declare match;
    iterate (match ; Matches) {
      SelList.Add(match, SelList.Count);
    }
    IDE.KeyboardManager.SendKeys("{VK_HOME}", TRUE);
    SelList.Hidden = FALSE;
  }
}

//
// Handle selection of multiple matches.
//
on Expander.SelList:>Accept()
{
  //
  // Get the text, and clear and close the window. Leaving the list up
  // interferes with the insertion.
  //
  declare expansionText = .GetString(.CurrentIndex);
  .Close();

  // Insert the selected match.
  //
  Expander.InsertMatch(expansionText);
}



