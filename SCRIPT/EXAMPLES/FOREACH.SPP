//--------------------------------------------------------------------------
// Object Scripting
// Copyright (c) 1996 by Borland International, All Rights Reserved
//
// FOREACH.SPP: For Each. Calls a function for all the nodes of the
//   given type in a project.
//--------------------------------------------------------------------------
print "foreach.spp";

//
// IDE imports.
//
import IDE;

//
// Calls a given function on all nodes of the given type in a project.
//   top           Starting node.
//   iterFunction  Function to call on each matching node. Needs to be
//                 a method (you can mimick this to pass a global function--
//                 see srchall.spp). The first parameter of the function is
//                 the node name, the second (optional) is the parent node
//                 (when available), and the third (optional) is a parameter
//                 passed to the function.
//   fileMask      String indicating which file types to work on. The default
//                 is ".cpp;.c". Note: .C also selects .CPP.
//   param         Parameter to pass to the function.
//
TraverseProject(top, iterFunction, fileMask, param)
{
  if (iterFunction == NULL) {
    IDE.Message("You must pass a function to TraverseProject().");
    return;
  }

  // If no mask is given, use default.
  //
  declare mask;
  if (!fileMask) {
    mask = new String(".cpp;.c");
  }
  else {
    mask = new String(fileMask);
  }

  declare abort = OK;  // Declare outside ForEach since it is recursive.

  //
  // Local function. Iterates the sub-nodes of the current node.
  //
  ForEach(node, parent)
  {
    if (abort == ABORT) {
      return ABORT;
    }

    if (node.IsValid) {

      // Check if the current node is in the mask.
      //
      if (mask.Index(node.Type) != 0) {
        abort = call iterFunction(node.InputName, parent.InputName, param);
        if (abort != OK) {
          return abort;
        }
      }

      // Iterate any sub-nodes.
      //
      declare tmpNode;
      declare current;
      iterate (tmpNode; node.ChildNodes) {
        current = new ProjectNode(tmpNode);
        ForEach(current, node);
        delete current;
      }
    }
  } // ForEach.

  // Iterate the nodes.
  //
  declare project = new ProjectNode(top);
  ForEach(project, NULL);

  delete mask;
  delete project;
}

