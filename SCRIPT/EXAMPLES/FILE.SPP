//--------------------------------------------------------------------------
// Object Scripting
// Copyright (c) 1996, 1997 by Borland International, All Rights Reserved
//
// FILE.SPP: File Classes. Includes configuration file management.
//
// FILES: MSG.SPP
//--------------------------------------------------------------------------
print typeid(module());

//
// IDE imports.
//
import scriptEngine;

//
// Load support module(s).
//
if (!scriptEngine.IsLoaded("msg")) scriptEngine.Load("msg");

//
// Windows imports.
//
import "mmsystem.dll"{
  bool   PlaySound       (char *, int, long); 
}

//
// Constants for PlaySound.
//
//#define SND_SYNC         0000  /* play synchronously (default) */
#define SND_ASYNC        0001  /* play asynchronously */
//#define SND_NODEFAULT    0002  /* silence (!default) if sound not found */
//#define SND_MEMORY       0004  /* pszSound points to a memory file */
//#define SND_LOOP         0008  /* loop the sound until next sndPlaySound */
//#define SND_NOSTOP       0010  /* don't stop any currently playing sound */
//#define SND_NOWAIT       00002000 /* don't wait if the driver is busy */
//#define SND_ALIAS        00010000 /* name is a registry alias */
//#define SND_ALIAS_ID     00110000 /* alias is a predefined ID */
#define SND_FILENAME     00020000 /* name is file name */
//#define SND_RESOURCE     00040004 /* name is resource name or atom */
//#define SND_PURGE        0040  /* purge non-static events for task */
//#define SND_APPLICATION  0080  /* look for app-specific association */

//
// class TFile
// ~~~~~ ~~~~~
// Base class.
//
class TFile(fileName) {
  declare FileName = fileName;

  //
  // Returns TRUE is the file exists; FALSE otherwise.
  //
  IsValid()
  {
    return FileExists(FileName) ? TRUE : FALSE;
  }
}

//
// class TFlatFile
// ~~~~~ ~~~~~~~~~
// TFlatFile encapsulates functionality for files placed in a private IDE
// edit buffer.
//
class TFlatFile(fileName) : TFile(fileName) {
  declare EdBuf;
  declare EdPos;
  declare EdBlk;

  CreateEditObjs(TRUE, FALSE);

  //
  // Instantiates a buffer and other objects for the file.
  //
  CreateEditObjs(private, readOnly)
  {
    EdBuf = new EditBuffer(FileName, private, readOnly);
    EdPos = new EditPosition(EdBuf);
    EdBlk = new EditBlock(EdBuf);
  }

  //
  // Returns an array of strings representing each line of the file. Passing
  // the string "containing" returns only those lines with that string in
  // them. Removes any newline and return characters by default. Pass TRUE
  // for "suppressTrim" to prevent this.
  //
  GetLines(containing, suppressTrim)
  {
    declare lines = new array[];
    declare line = new String();

    declare i = 0;
    declare row = 1;
    do {
      EdPos.Move(row, 1);
      line.Text = EdPos.Read();
      if (containing == "" || line.Index(containing)) {
        if (!suppressTrim) line = line.Trim();
        lines[i] = line.Text;
        i++;
      }
      row++;
    } while (row - 1 < EdPos.LastRow);

    return lines;
  }

  //
  // Returns the first text found between two given markers. If useEOF is set
  // TRUE, EOF will be used if the second marker is not found. Returns NULL
  // on failure.
  //
  GetSandwichedText(marker1, marker2, useEOF)
  {
    if (!EdPos.Search(marker1, TRUE, FALSE)) {
      return NULL;
    }
    EdPos.MoveRelative(1, 0);
    EdPos.MoveBOL();
    EdBlk.Begin();
    if (!EdPos.Search(marker2, TRUE, FALSE) && useEOF) {
      EdPos.MoveEOF();
    }
    EdBlk.End();
    return EdBlk.Text;
  }

  //
  // Deletes the contents of the file. Returns TRUE on success; false
  // otherwise.
  //
  Delete()
  {
    if (!EdPos.Move(1, 1)) return FALSE;
    EdBlk.Begin();
    if (!EdPos.MoveEOF()) return FALSE;
    EdBlk.End();
    return EdBlk.Delete();
  }

  //
  // Appends the given text to the end of the buffer. Adds a \n\r sequence if
  // EOF is not column one.
  //
  Append(text)
  {
    EdPos.MoveEOF();
    if (EdPos.Column != 1) EdPos.InsertText("\n\r");
    EdPos.InsertText(text);
  }

  //
  // Closes the buffer opened for the file. Pass TRUE to save changes
  // made to the buffer.
  //
  Close(save)
  {
    if (save) EdBuf.Save();
    EdBuf.Destroy();
  }

  //
  // Destructor.
  //
  ~TFlatFile()
  {
    Close();
  }
}

//
// class TConfigFile
// ~~~~~ ~~~~~~~~~~~
// TConfigFile encapsulates functionality for configuration files.
//
class TConfigFile(fileName) : TFlatFile(fileName) {

  //
  // Returns a string representing the value of the given key or a
  // default value if the key is not found. Treats ";" as comment
  // character, which must be in column 1.
  //
  GetValue(key, defaultVal)
  {
    declare sTmp = new String();
    if (EdPos.Search(key, TRUE, FALSE)) {
      EdPos.MoveBOL();
      if (EdPos.Character == 59) {  // Check for comment indicator.
        EdPos.MoveEOL();
        return GetValue(key, defaultVal);  // Recursively look elsewhere.
      }
      sTmp.Text = EdPos.Read();
      declare position = sTmp.Index("=");
      if (!position) {  // No equals character.
        return defaultVal;
      }
      sTmp = sTmp.SubString(position);
      sTmp = sTmp.Trim();  // Remove trailing \r\n.
      return sTmp.Text;
    }
    return defaultVal;
  }

  //
  // Writes the specified value for the specified key to the file.
  // Treats ";" as comment character, which must be in column 1.
  // Adds the key if not found. Returns TRUE on success.
  //
  WriteValue(key, value)
  {
    // Find existing key.
    //
    if (EdPos.Search(key, TRUE, FALSE)) {
      EdPos.MoveBOL();
      if (EdPos.Character == 59) {  // Check for comment indicator.
        EdPos.MoveEOL();
        return WriteValue(key, value);  // Recursively look for key elsewhere.
      }

      // Add the value.
      //
      declare EdBlk = new EditBlock(EdBuf);
      EdPos.Search("=", FALSE, FALSE);
      EdBlk.Begin();
      EdPos.MoveEOL();
      EdBlk.End();
      EdBlk.Delete();
      EdPos.MoveEOL();
      EdPos.InsertText(value);
      return TRUE;
    }

    // Key not found. Add the key and the value.
    //
    else {
      EdPos.MoveEOF();
      EdPos.InsertText("\n\r" + key + "=" + value);
      return TRUE;
    }
  }
}

//
// class TWAVFile
// ~~~~~ ~~~~~~~~~
// TWAVFile encapsulates functionality for WAV files.
//
class TWAVFile(fileName) : TFile(fileName) {

  //
  // Plays the file.
  //
  Play()
  {
    PlaySound(FileName, NULL, SND_FILENAME | SND_ASYNC);
  }
}
