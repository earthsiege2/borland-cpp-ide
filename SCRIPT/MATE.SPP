//----------------------------------------------------------------------------
// cScript
// (C) Copyright 1995, 1997 by Borland International, All Rights Reserved
//
// MATE.SPP
//    Provides complimentary symbol matching functionality.
//
// $Revision:   1.14  $
//
//----------------------------------------------------------------------------

import editor;
import IDE;

// mark this module as being a library module
library;

//
// A placeholding method used to trigger the load of this module.
//
LoadMateFunctionality(){
   // do nothing
}


class MateManagement {

   declare nDirection = SEARCH_FORWARD;
   declare sMatching  = NULL;
   declare nMatchIndex = 0;
   declare matchData = new array[];

   declare ifMatch =      {"if",   "endif"};
   declare parenMatch =   {"(",    ")"};
   declare bracketMatch = {"[",    "]"};
   declare curlyMatch =   {"{",    "}"};
   declare dblQMatch =    {"\"",   "\""};
   declare snglQMatch =   {"\'",   "\'"};
   declare angleMatch =   {"<",    ">"};

   declare mateSet = "[\[\](){}\\<>]";

   matchData[0] = ifMatch;
   matchData[1] = parenMatch;
   matchData[2] = bracketMatch;
   matchData[3] = curlyMatch;
   matchData[4] = dblQMatch;
   matchData[5] = snglQMatch;
   matchData[6] = angleMatch;

   DetermineCorresponding(declare sRequest) {
      for(nMatchIndex = 0;matchData[nMatchIndex] != NULL;nMatchIndex++){
         if (sRequest == matchData[nMatchIndex][0]){
            nDirection = SEARCH_FORWARD;
            sMatching = matchData[nMatchIndex][1];
            break;
         }

         if (sRequest == matchData[nMatchIndex][1]){
            nDirection = SEARCH_BACKWARD;
            sMatching  = matchData[nMatchIndex][0];
            break;
         }
      }

      if (matchData[nMatchIndex] == NULL)
         return FALSE;

      return TRUE;
   }

   LocateCorresponding(declare nDirectionOverride) {
      // hopefully our caller will direct us in what to do on an
      // ambiguos match, otherwise we will guess and scan forward.

      declare ep = editor.TopView.Position;

      declare nEndCorrection = 0;
      declare nStartCorrection = 0;

      if (matchData[nMatchIndex][0] == matchData[nMatchIndex][1]) {
         nDirection = (nDirectionOverride == SEARCH_BACKWARD) ?
            SEARCH_BACKWARD : SEARCH_FORWARD;
      }

      if (nDirection == SEARCH_FORWARD) {
         nStartCorrection = 1;
         nEndCorrection = -1;
      } else {
         nStartCorrection = 0;
         nEndCorrection = 0;
      }

      declare nResult = 1;
      declare nNestingLevel = 1;
      declare acNested = NULL;
      if (matchData[nMatchIndex][0] == "[")
         acNested = "[\\" + matchData[nMatchIndex][0] +"\\" + matchData[nMatchIndex][1] + "]";
      else
         acNested = "[" + matchData[nMatchIndex][0] + matchData[nMatchIndex][1] + "]";

      while (nResult && nNestingLevel) {
         ep.MoveRelative(0, nStartCorrection);

         nResult = ep.Search(acNested, TRUE, TRUE, nDirection);

         if (nResult) {
            ep.MoveRelative(0, nEndCorrection);
            if (ep.Read(1) == sMatching)  
               nNestingLevel--;
            else
               nNestingLevel++;
            }
      }

      if (nResult == 0) {
         return FALSE;
      }

      return TRUE;
   }

   ValidCharacter(declare character) {
      // see if there is anything to match
      if (character == ' ' ||
         character == VIRTUAL_TAB ||
         character == VIRTUAL_PAST_EOF ||
         character == VIRTUAL_PAST_EOL)  {
         return FALSE;
      }

      // did we pull a peice of an identifier or a symbol?
      if( ( ('a' <= character) && (character <= 'z')) ||
          (('A' <= character) && (character <= 'Z')) ||
          (('0' <= character) && (character <= '9')) ||
          (character == '_')){
            return FALSE;
      }

      return TRUE;
   }
};

declare MateManagement MateManager;

//
// This method is responsible for navigating to the delimeter that matches
// the "current" delimeter
//
on editor:>Mate(declare dirIfAmbiguous){
   declare ep = .TopView.Position;
   declare nOriginalRow = ep.Row;
   declare nOriginalColumn = ep.Column;
   declare matchingStr = .TopView.Position.Read(1);

   if (!MateManager.DetermineCorresponding(matchingStr)) {
      IDE.MessageBeep();
      IDE.StatusBar = "Matching delimeter for '" + matchingStr + "'" + " is unknown.";
      return FALSE;
   }

   IDE.StatusBar = "Matching '" + matchingStr + "'...";

   if (!MateManager.LocateCorresponding(dirIfAmbiguous)) {
      IDE.MessageBeep();
      IDE.StatusBar = "Failed to find matching '" + matchingStr + "'";
      ep.Move(nOriginalRow,nOriginalColumn);
      return FALSE;
   }

   IDE.StatusBar = "Matched '" + matchingStr + "' with '" + MateManager.sMatching + "'";
   return TRUE;
}

on editor:>MateQuiet(declare matchingStr, declare dirIfAmbiguous){
   if (!MateManager.DetermineCorresponding(matchingStr))
       return FALSE;
     
   if (!MateManager.LocateCorresponding(dirIfAmbiguous))
       return FALSE;

   return TRUE;
}     
